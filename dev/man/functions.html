<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · FinEtools.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FinEtools.jl</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../guide/guide.html">Guide</a></li><li><span class="tocitem">Types and Functions</span><ul><li><a class="tocitem" href="types.html">Types</a></li><li class="is-active"><a class="tocitem" href="functions.html">Functions</a><ul class="internal"><li><a class="tocitem" href="#Physical-units-1"><span>Physical units</span></a></li><li><a class="tocitem" href="#Bounding-box-functions-1"><span>Bounding box functions</span></a></li><li><a class="tocitem" href="#Coordinate-systems-1"><span>Coordinate systems</span></a></li><li><a class="tocitem" href="#Matrix-utilities-1"><span>Matrix utilities</span></a></li><li><a class="tocitem" href="#Finite-element-sets-1"><span>Finite element sets</span></a></li><li><a class="tocitem" href="#Finite-element-nodes-1"><span>Finite element nodes</span></a></li><li><a class="tocitem" href="#Finite-element-node-to-element-map-1"><span>Finite element node-to-element map</span></a></li><li><a class="tocitem" href="#Selecting-nodes-and-elements-1"><span>Selecting nodes and elements</span></a></li><li><a class="tocitem" href="#Fields-1"><span>Fields</span></a></li><li><a class="tocitem" href="#Integration-rule-1"><span>Integration rule</span></a></li><li><a class="tocitem" href="#Integration-domain-1"><span>Integration domain</span></a></li><li><a class="tocitem" href="#Assembly-of-matrices-and-vectors-1"><span>Assembly of matrices and vectors</span></a></li><li><a class="tocitem" href="#Meshing-1"><span>Meshing</span></a></li><li><a class="tocitem" href="#Vector-cache-utilities-1"><span>Vector-cache utilities</span></a></li><li><a class="tocitem" href="#Surface-normal-utilities-1"><span>Surface-normal utilities</span></a></li><li><a class="tocitem" href="#Force-intensity-1"><span>Force intensity</span></a></li><li><a class="tocitem" href="#Rotation-utilities-1"><span>Rotation utilities</span></a></li><li><a class="tocitem" href="#FEM-machines-1"><span>FEM machines</span></a></li><li><a class="tocitem" href="#Algorithms-1"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Material-models-1"><span>Material models</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Types and Functions</a></li><li class="is-active"><a href="functions.html">Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="functions.html">Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/master/docs/src/man/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-1"><a class="docs-heading-anchor" href="#Functions-1">Functions</a><a class="docs-heading-anchor-permalink" href="#Functions-1" title="Permalink"></a></h1><h2 id="Physical-units-1"><a class="docs-heading-anchor" href="#Physical-units-1">Physical units</a><a class="docs-heading-anchor-permalink" href="#Physical-units-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.PhysicalUnitModule.phun-Tuple{String}" href="#FinEtools.PhysicalUnitModule.phun-Tuple{String}"><code>FinEtools.PhysicalUnitModule.phun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">phun(str::String; system_of_units = :SI, base_time_units = :SEC)</code></pre><p>Evaluate an expression in physical units.</p><p><strong>Example</strong></p><pre><code class="language-none">pu = ustring -&gt; phun(ustring; system_of_units = :SIMM)
E1s = 130.0*pu(&quot;GPa&quot;)</code></pre><p>yields 1.3e+5 (in mega Pascal) whereas</p><pre><code class="language-none">130.0*phun(&quot;GPa&quot;; system_of_units = :SI)</code></pre><p>yields 1.3e+11 (in Pascal)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/PhysicalUnitModule.jl#L12-L30">source</a></section></article><h2 id="Bounding-box-functions-1"><a class="docs-heading-anchor" href="#Bounding-box-functions-1">Bounding box functions</a><a class="docs-heading-anchor-permalink" href="#Bounding-box-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.boundingbox-Tuple{AbstractArray}" href="#FinEtools.BoxModule.boundingbox-Tuple{AbstractArray}"><code>FinEtools.BoxModule.boundingbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boundingbox(x::AbstractArray)</code></pre><p>Compute the bounding box of the points in <code>x</code>.</p><p><code>x</code> = holds points, one per row.</p><p>Returns <code>box</code> = bounding box     for 1-D <code>box=[minx,maxx]</code>, or     for 2-D <code>box=[minx,maxx,miny,maxy]</code>, or     for 3-D <code>box=[minx,maxx,miny,maxy,minz,maxz]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/BoxModule.jl#L91-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.boxesoverlap-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#FinEtools.BoxModule.boxesoverlap-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>FinEtools.BoxModule.boxesoverlap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxesoverlap(box1::AbstractVector, box2::AbstractVector)</code></pre><p>Do the given boxes overlap?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/BoxModule.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.inbox-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#FinEtools.BoxModule.inbox-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>FinEtools.BoxModule.inbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inbox(box::AbstractVector, x::AbstractVector)</code></pre><p>Is the given location inside the box?</p><ul><li><code>box</code> = vector entries arranged as <a href="man/or adjusted for lower space dimension">minx,maxx,miny,maxy,minz,maxz</a>.</li></ul><p>Note: point on the boundary of the box is counted as being inside.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/BoxModule.jl#L10-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.inflatebox!-Tuple{AbstractArray{T,1} where T,Number}" href="#FinEtools.BoxModule.inflatebox!-Tuple{AbstractArray{T,1} where T,Number}"><code>FinEtools.BoxModule.inflatebox!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inflatebox!(box::AbstractVector, inflatevalue::Number)</code></pre><p>Inflate the box by the value supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/BoxModule.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.initbox!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#FinEtools.BoxModule.initbox!-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>FinEtools.BoxModule.initbox!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initbox!(box::AbstractVector, x::AbstractVector)</code></pre><p>Initialize a bounding box with a single point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/BoxModule.jl#L39-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.intersectboxes-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#FinEtools.BoxModule.intersectboxes-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>FinEtools.BoxModule.intersectboxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersectboxes(box1::AbstractVector, box2::AbstractVector)</code></pre><p>Compute the intersection of two boxes.</p><p>The function returns an empty box (length(b) == 0) if the intersection is empty; otherwise a box is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/BoxModule.jl#L141-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.BoxModule.updatebox!-Tuple{AbstractArray{T,1} where T,AbstractArray}" href="#FinEtools.BoxModule.updatebox!-Tuple{AbstractArray{T,1} where T,AbstractArray}"><code>FinEtools.BoxModule.updatebox!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updatebox!(box::AbstractVector, x::AbstractArray)</code></pre><p>Update a box with another location, or create a new box.</p><p>If the  <code>box</code> does not have  the correct dimensions,  it is correctly sized.</p><p><code>box</code> = bounding box     for 1-D <code>box=[minx,maxx]</code>, or     for 2-D <code>box=[minx,maxx,miny,maxy]</code>, or     for 3-D <code>box=[minx,maxx,miny,maxy,minz,maxz]</code>     The <code>box</code> is expanded to include the     supplied location <code>x</code>.   The variable <code>x</code>  can hold multiple points in rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/BoxModule.jl#L55-L68">source</a></section></article><h2 id="Coordinate-systems-1"><a class="docs-heading-anchor" href="#Coordinate-systems-1">Coordinate systems</a><a class="docs-heading-anchor-permalink" href="#Coordinate-systems-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.gen_iso_csmat!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2},Int64}" href="#FinEtools.CSysModule.gen_iso_csmat!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2},Int64}"><code>FinEtools.CSysModule.gen_iso_csmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gen_iso_csmat(XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>Compute the coordinate system  for an isotropic material using information available  by looking at the coordinate curves of isoparametric finite elements.</p><ul><li><code>XYZ</code>= location  in physical coordinates,</li><li><code>tangents</code>= tangent vector matrix, tangents to the parametric coordinate curves  in the element,</li><li><code>fe_label</code>= finite element label.</li></ul><p>The basic assumption here is that the material is isotropic, and therefore the choice of the material directions does not really matter as long as they correspond to the dimensionality of the element. For instance a one-dimensional element (L2 as an example) may be embedded in a three-dimensional space.</p><p>This function assumes that it is being called for an mdim-dimensional manifold element, which is embedded in a sdim-dimensional Euclidean space. If <code>mdim == sdim</code>, the coordinate system matrix is the identity; otherwise the local coordinate directions are aligned with the linear subspace defined by the tangent vectors.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"></div></div><p>This <em>cannot</em> be reliably used to produce consistent stresses because each quadrature point gets a local coordinate system which depends on the orientation of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/CSysModule.jl#L113-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.CSysModule.updatecsmat!-Tuple{CSys,Array{Float64,2},Array{Float64,2},Int64}" href="#FinEtools.CSysModule.updatecsmat!-Tuple{CSys,Array{Float64,2},Array{Float64,2},Int64}"><code>FinEtools.CSysModule.updatecsmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function updatecsmat!(self::CSys, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>Update the coordinate system orientation matrix.</p><p>The  coordinate system matrix is updated based upon the location <code>XYZ</code> of the evaluation point, and possibly on the Jacobian matrix <code>tangents</code> within the element in which the coordinate system matrix is evaluated,  or perhaps on the label <code>fe_label</code> of the finite element.</p><p>After this function returns, the coordinate system matrix can be retrieved from the buffer as <code>self.csmat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/CSysModule.jl#L95-L107">source</a></section></article><h2 id="Matrix-utilities-1"><a class="docs-heading-anchor" href="#Matrix-utilities-1">Matrix utilities</a><a class="docs-heading-anchor-permalink" href="#Matrix-utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_btdb_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2}}" href="#FinEtools.MatrixUtilityModule.add_btdb_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2}}"><code>FinEtools.MatrixUtilityModule.add_btdb_ut_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_btdb_ut_only!(Ke::FFltMat, B::FFltMat, Jac_w::FFlt,
              D::FFltMat, DB::FFltMat)</code></pre><p>Add the product  <code>(B&#39;*(D*(Jac*w[j]))*B)</code>, to the elementwise matrix Ke. <em>Only upper triangle</em> is computed; the lower triangle is not touched. (Use <code>complete_lt!</code> to complete the lower triangle, if needed.)</p><p>The matrix Ke is assumed to be suitably initialized.</p><p>The matrix Ke is modified.  The matrices B and D are not modified inside this function. The scratch buffer DB is overwritten during each call of this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L149-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_btsigma!-Tuple{Array{Float64,1},Array{Float64,2},Float64,Array{Float64,1}}" href="#FinEtools.MatrixUtilityModule.add_btsigma!-Tuple{Array{Float64,1},Array{Float64,2},Float64,Array{Float64,1}}"><code>FinEtools.MatrixUtilityModule.add_btsigma!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_btsigma!(Fe::FFltVec, B::FFltMat, coefficient::FFlt, sigma::FFltVec)</code></pre><p>Add the product  <code>B&#39;*(sigma*coefficient)</code>, to the elementwise vector <code>Fe</code>.</p><p>The vector <code>Fe</code> is assumed to be suitably initialized.</p><p>The vector <code>Fe</code> is modified.  The vector <code>sigma</code> is not modified inside this function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L192-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_btv!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,1},Float64}" href="#FinEtools.MatrixUtilityModule.add_btv!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,1},Float64}"><code>FinEtools.MatrixUtilityModule.add_btv!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_btv!(elvec::FFltVec, B::FFltMat, sig::FFltMat, Jac_w_coeff::FFlt)</code></pre><p>Add product of the strain-displacement matrix transpose times the stress vector.</p><p>Note:  the coefficient <code>Jac_w_coeff</code> will be typically  NEGATIVE.</p><p>The argument <code>elvec</code> needs to be suitably  initialized before the first call (filled with zeros, for instance),  and it is updated upon return. The arguments <code>B</code>, <code>sig</code> are not modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L243-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_gkgt_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2}}" href="#FinEtools.MatrixUtilityModule.add_gkgt_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64,Array{Float64,2},Array{Float64,2}}"><code>FinEtools.MatrixUtilityModule.add_gkgt_ut_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_gkgt_ut_only!(Ke::FFltMat, gradN::FFltMat, Jac_w::FFlt,
  kappa_bar::FFltMat, kappa_bargradNT::FFltMat)</code></pre><p>Add the product <code>gradN*kappa_bar*gradNT*(Jac*w[j])</code> to the elementwise matrix <code>Ke</code>. <em>Only upper triangle</em> is computed; the lower triangle is not touched. (Use <code>complete_lt!</code> to complete the lower triangle, if needed.)</p><p>The matrix <code>Ke</code> is assumed to be suitably initialized.</p><p>Upon return,  the matrix <code>Ke</code> is updated.  The scratch buffer <code>kappa_bargradNT</code> is overwritten during each call of this function. The matrices <code>gradN</code> and <code>kappa_bar</code> are not modified inside this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L85-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_mggt_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64}" href="#FinEtools.MatrixUtilityModule.add_mggt_ut_only!-Tuple{Array{Float64,2},Array{Float64,2},Float64}"><code>FinEtools.MatrixUtilityModule.add_mggt_ut_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_mggt_ut_only!(Ke::FFltMat, gradN::FFltMat, mult::FFlt)</code></pre><p>Add the product <code>gradN*mult*gradNT*(Jac*w[j])</code> to the elementwise matrix <code>Ke</code>. The argument <code>mult</code> is a scalar. <em>Only upper triangle</em> is computed; the lower triangle is not touched. (Use <code>complete_lt!</code> to complete the lower triangle, if needed.)</p><p>The matrix <code>Ke</code> is assumed to be suitably initialized.</p><p>The matrix <code>Ke</code> is modified.  The matrix <code>gradN</code> is not modified inside this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.add_nnt_ut_only!-Union{Tuple{T}, Tuple{Array{T,2},Array{Float64,2},T}} where T&lt;:Number" href="#FinEtools.MatrixUtilityModule.add_nnt_ut_only!-Union{Tuple{T}, Tuple{Array{T,2},Array{Float64,2},T}} where T&lt;:Number"><code>FinEtools.MatrixUtilityModule.add_nnt_ut_only!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_nnt_ut_only!(Ke::FFltMat, Nn::FFltMat, Jac_w_coeff::FFlt)</code></pre><p>Add the product  <code>Nn*(Nn&#39;*(coeff*(Jac*w(j)))</code>, to the elementwise matrix <code>Ke</code>. <em>Only upper triangle</em> is computed; the lower triangle is not touched.</p><p>The matrix <code>Ke</code> is assumed to be suitably initialized.</p><p>The matrix <code>Ke</code> is modified.  The matrix <code>Nn</code> is not modified inside this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L215-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.adjugate3!-Tuple{Any,Any}" href="#FinEtools.MatrixUtilityModule.adjugate3!-Tuple{Any,Any}"><code>FinEtools.MatrixUtilityModule.adjugate3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjugate3!(B, A)</code></pre><p>Compute the adjugate matrix of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.complete_lt!-Tuple{Array{Float64,2}}" href="#FinEtools.MatrixUtilityModule.complete_lt!-Tuple{Array{Float64,2}}"><code>FinEtools.MatrixUtilityModule.complete_lt!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">complete_lt!(Ke::FFltMat)</code></pre><p>Complete the lower triangle of the elementwise matrix <code>Ke</code>.</p><p>The matrix <code>Ke</code> is modified  inside this function. The upper-triangle  entries  are copied  across the diagonal to the lower triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L129-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.detC-Tuple{Val{3},Array{Float64,2}}" href="#FinEtools.MatrixUtilityModule.detC-Tuple{Val{3},Array{Float64,2}}"><code>FinEtools.MatrixUtilityModule.detC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">detC(::Val{3}, C::FFltMat)</code></pre><p>Compute determinant of 3X3 <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L475-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.jac!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2}}" href="#FinEtools.MatrixUtilityModule.jac!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2}}"><code>FinEtools.MatrixUtilityModule.jac!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">jac!(J::FFltMat, ecoords::FFltMat,gradNparams::FFltMat)</code></pre><p>Compute the Jacobian matrix at the quadrature point.</p><p>Arguments: <code>J</code> = Jacobian matrix, overwritten  inside the function <code>ecoords</code> = matrix of the node coordinates for the element. <code>gradNparams</code> = matrix of basis function gradients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L25-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.loc!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2}}" href="#FinEtools.MatrixUtilityModule.loc!-Tuple{Array{Float64,2},Array{Float64,2},Array{Float64,2}}"><code>FinEtools.MatrixUtilityModule.loc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">loc!(loc::FFltMat, ecoords::FFltMat, N::FFltMat)</code></pre><p>Compute the location of the quadrature point.</p><p>Arguments: <code>loc</code> = matrix of coordinates, overwritten  inside the function <code>ecoords</code> = matrix of the node coordinates for the element. <code>N</code> = matrix of basis function values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L11-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.locjac!-NTuple{5,Array{Float64,2}}" href="#FinEtools.MatrixUtilityModule.locjac!-NTuple{5,Array{Float64,2}}"><code>FinEtools.MatrixUtilityModule.locjac!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locjac!(loc::FFltMat, J::FFltMat, ecoords::FFltMat, N::FFltMat, gradNparams::FFltMat)</code></pre><p>Compute location and Jacobian matrix at the quadrature point.</p><p>Arguments: <code>loc</code> = matrix of coordinates, overwritten  inside the function <code>J</code> = Jacobian matrix, overwritten  inside the function <code>ecoords</code> = matrix of the node coordinates for the element. <code>N</code> = matrix of basis function values <code>gradNparams</code> = matrix of basis function gradients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L39-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Any,Any,Any}" href="#FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Any,Any,Any}"><code>FinEtools.MatrixUtilityModule.mulCAB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mulCAB!(C, A, B)</code></pre><p>Compute the matrix <code>C = A * B</code></p><p>The use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.</p><p>Note: See the thread https://discourse.julialang.org/t/ann-loopvectorization/32843/36</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L418-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Val{3},Any,Any,Any}" href="#FinEtools.MatrixUtilityModule.mulCAB!-Tuple{Val{3},Any,Any,Any}"><code>FinEtools.MatrixUtilityModule.mulCAB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mulCAB!(::Val{3}, C, A, B)</code></pre><p>Compute the product of 3X3 matrices <code>C = A * B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAB!-Union{Tuple{T}, Tuple{Array{T,1},Any,Array{T,1}}} where T" href="#FinEtools.MatrixUtilityModule.mulCAB!-Union{Tuple{T}, Tuple{Array{T,1},Any,Array{T,1}}} where T"><code>FinEtools.MatrixUtilityModule.mulCAB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mulCAB!(C::Vector{T}, A, B::Vector{T})  where {T}</code></pre><p>Compute the product <code>C = A * B</code>, where <code>C</code> and <code>B</code> are &quot;vectors&quot;.</p><p>The use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L491-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Any,Any,Any}" href="#FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Any,Any,Any}"><code>FinEtools.MatrixUtilityModule.mulCABt!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mulCABt!(C, A, B)</code></pre><p>Compute the matrix <code>C = A * B&#39;</code></p><p>The use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L452-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Val{3},Any,Any,Any}" href="#FinEtools.MatrixUtilityModule.mulCABt!-Tuple{Val{3},Any,Any,Any}"><code>FinEtools.MatrixUtilityModule.mulCABt!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mulCABt!(::Val{3}, C, A, B)</code></pre><p>Compute the product of 3X3 matrices <code>C = A * Transpose(B)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L345-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Any,Any,Any}" href="#FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Any,Any,Any}"><code>FinEtools.MatrixUtilityModule.mulCAtB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mulCAtB!(C, A, B)</code></pre><p>Compute the matrix <code>C = A&#39; * B</code></p><p>The use of BLAS is purposefully avoided in order to eliminate contentions of multi-threaded execution of the library code with the user-level threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L365-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Val{3},Any,Any,Any}" href="#FinEtools.MatrixUtilityModule.mulCAtB!-Tuple{Val{3},Any,Any,Any}"><code>FinEtools.MatrixUtilityModule.mulCAtB!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mulCAtB!(::Val{3}, C, A, B)</code></pre><p>Compute the product of 3X3 matrices <code>C = Transpose(A) * B</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L325-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatrixUtilityModule.symmetrize!-Tuple{Any}" href="#FinEtools.MatrixUtilityModule.symmetrize!-Tuple{Any}"><code>FinEtools.MatrixUtilityModule.symmetrize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symmetrize!(a)</code></pre><p>Make the matrix on input symmetric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatrixUtilityModule.jl#L290-L294">source</a></section></article><h2 id="Finite-element-sets-1"><a class="docs-heading-anchor" href="#Finite-element-sets-1">Finite element sets</a><a class="docs-heading-anchor-permalink" href="#Finite-element-sets-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.cat-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFESet" href="#Base.cat-Union{Tuple{T}, Tuple{T,T}} where T&lt;:AbstractFESet"><code>Base.cat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cat(self::T,  other::T) where {T&lt;:AbstractFESet}</code></pre><p>Concatenate the connectivities of two FE sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.count-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet" href="#Base.count-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet"><code>Base.count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">count(self::T)::FInt where {T&lt;:AbstractFESet}</code></pre><p>Get the number of individual connectivities in the FE set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T&lt;:AbstractFESet0Manifold" href="#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T&lt;:AbstractFESet0Manifold"><code>FinEtools.FESetModule.Jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobian(self::T, J::FFltMat)::FFlt where {T&lt;:AbstractFESet1Manifold}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix, columns are tangent to parametric coordinates curves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L310-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T&lt;:AbstractFESet1Manifold" href="#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T&lt;:AbstractFESet1Manifold"><code>FinEtools.FESetModule.Jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobian(self::T, J::FFltMat)::FFlt where {T&lt;:AbstractFESet1Manifold}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix, columns are tangent to parametric coordinates curves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L321-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T&lt;:AbstractFESet2Manifold" href="#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T&lt;:AbstractFESet2Manifold"><code>FinEtools.FESetModule.Jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobian(self::T, J::FFltMat)::FFlt where {T&lt;:AbstractFESet2Manifold}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix, columns are tangent to parametric coordinates curves.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L351-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T&lt;:AbstractFESet3Manifold" href="#FinEtools.FESetModule.Jacobian-Union{Tuple{T}, Tuple{T,Array{Float64,2}}} where T&lt;:AbstractFESet3Manifold"><code>FinEtools.FESetModule.Jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobian(self::T, J::FFltMat)::FFlt where {T&lt;:AbstractFESet3Manifold}</code></pre><p>Evaluate the volume Jacobian.</p><p><code>J</code> = Jacobian matrix, columns are tangent to parametric coordinates curves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L395-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.bfun-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.bfun-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.bfun</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bfun(self::T,  param_coords::FFltVec)::FFltMat where {T&lt;:AbstractFESet}</code></pre><p>Compute the values of the basis functions.</p><p>Compute the values of the basis functions at a given parametric coordinate. One basis function per row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L157-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.bfundpar-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.bfundpar-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.bfundpar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bfundpar(self::T,  param_coords::FFltVec)::FFltMat where {T&lt;:AbstractFESet}</code></pre><p>Compute the values of the basis function gradients.</p><p>Compute the values of the basis function gradients with respect to the parametric coordinates at a given parametric coordinate. One basis function gradients per row.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L169-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.boundaryconn-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.boundaryconn-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.boundaryconn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boundaryconn(self::T) where {T&lt;:AbstractFESet}</code></pre><p>Get boundary connectivity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.boundaryfe-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.boundaryfe-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.boundaryfe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boundaryfe(self::T) where {T&lt;:AbstractFESet}</code></pre><p>Return the constructor of the type of the boundary finite element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L148-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.centroidparametric-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.centroidparametric-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.centroidparametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">centroidparametric(self::T) where {T&lt;:AbstractFESet}</code></pre><p>Return the parametric coordinates  of the centroid of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.connasarray-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM" href="#FinEtools.FESetModule.connasarray-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM"><code>FinEtools.FESetModule.connasarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connasarray(self::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}</code></pre><p>Return the connectivity as an array.</p><p>Return the connectivity as an integer array (matrix), where the number of rows matches the number of connectivities in the set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L121-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.fromarray!-Union{Tuple{NODESPERELEM}, Tuple{AbstractFESet{NODESPERELEM},Array{Int64,2}}} where NODESPERELEM" href="#FinEtools.FESetModule.fromarray!-Union{Tuple{NODESPERELEM}, Tuple{AbstractFESet{NODESPERELEM},Array{Int64,2}}} where NODESPERELEM"><code>FinEtools.FESetModule.fromarray!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fromarray!(self::AbstractFESet{NODESPERELEM}, conn::FIntMat) where {NODESPERELEM}</code></pre><p>Set  the connectivity from an integer array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.gradN!-Tuple{AbstractFESet1Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}" href="#FinEtools.FESetModule.gradN!-Tuple{AbstractFESet1Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}"><code>FinEtools.FESetModule.gradN!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradN!(self::AbstractFESet1Manifold, gradN::FFltMat, gradNparams::FFltMat,
  redJ::FFltMat)</code></pre><p>Compute the gradient of the basis functions with the respect to the &quot;reduced&quot; spatial coordinates.</p><ul><li><code>gradN</code>= output,  matrix of gradients,  one per row</li><li><code>gradNparams</code>= matrix of gradients with respect to parametric coordinates, one per row</li><li><code>redJ</code>= reduced Jacobian matrix <code>redJ=transpose(Rm)*J</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L334-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.gradN!-Tuple{AbstractFESet2Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}" href="#FinEtools.FESetModule.gradN!-Tuple{AbstractFESet2Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}"><code>FinEtools.FESetModule.gradN!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradN!(self::AbstractFESet2Manifold, gradN::FFltMat, gradNparams::FFltMat,
  redJ::FFltMat)</code></pre><p>Compute the gradient of the basis functions with the respect to the &quot;reduced&quot; spatial coordinates.</p><ul><li><code>gradN</code>= output,  matrix of gradients,  one per row</li><li><code>gradNparams</code>= matrix of gradients with respect to parametric coordinates, one per row</li><li><code>redJ</code>= reduced Jacobian matrix <code>redJ=transpose(Rm)*J</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L369-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.gradN!-Tuple{AbstractFESet3Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}" href="#FinEtools.FESetModule.gradN!-Tuple{AbstractFESet3Manifold,Array{Float64,2},Array{Float64,2},Array{Float64,2}}"><code>FinEtools.FESetModule.gradN!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradN!(self::AbstractFESet3Manifold, gradN::FFltMat, gradNparams::FFltMat,
  redJ::FFltMat)</code></pre><p>Compute the gradient of the basis functions with the respect to the &quot;reduced&quot; spatial coordinates.</p><ul><li><code>gradN</code>= output,  matrix of gradients,  one per row</li><li><code>gradNparams</code>= matrix of gradients with respect to parametric coordinates, one per row</li><li><code>redJ</code>= reduced Jacobian matrix <code>redJ=transpose(Rm)*J</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L412-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.inparametric-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.inparametric-Union{Tuple{T}, Tuple{T,Array{Float64,1}}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.inparametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inparametric(self::AbstractFESet, param_coords::FFltVec)</code></pre><p>Are given parametric coordinates inside the element parametric domain?</p><p>Return a Boolean: is the point inside, true or false?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L252-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.manifdim-Union{Tuple{AbstractFESet0Manifold{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM" href="#FinEtools.FESetModule.manifdim-Union{Tuple{AbstractFESet0Manifold{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM"><code>FinEtools.FESetModule.manifdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">manifdim(me)</code></pre><p>Get the manifold dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.map2parametric-Union{Tuple{T}, Tuple{T,Array{Float64,2},Array{Float64,1}}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.map2parametric-Union{Tuple{T}, Tuple{T,Array{Float64,2},Array{Float64,1}}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.map2parametric</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">map2parametric(self::T, x::FFltMat, pt::FFltVec;
    tolerance = 0.001, maxiter =5) where {T&lt;:AbstractFESet}</code></pre><p>Map a spatial location to parametric coordinates.</p><ul><li><code>x</code>=array of spatial coordinates of the nodes, size(x) = nbfuns x dim,</li><li><code>c</code>= spatial location</li><li><code>tolerance</code> = tolerance in parametric coordinates; default is 0.001.</li></ul><p><strong>Return</strong></p><ul><li><code>success</code> = Boolean flag, true if successful, false otherwise.</li><li><code>pc</code> = Returns a row array of parametric coordinates if the solution was successful, otherwise NaN are returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L263-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.nodesperelem-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM" href="#FinEtools.FESetModule.nodesperelem-Union{Tuple{AbstractFESet{NODESPERELEM}}, Tuple{NODESPERELEM}} where NODESPERELEM"><code>FinEtools.FESetModule.nodesperelem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodesperelem(fes::AbstractFESet{NODESPERELEM}) where {NODESPERELEM}</code></pre><p>Provide the number of nodes per element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.setlabel!-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.setlabel!-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.setlabel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setlabel!(self::T, val::FIntVec) where {T&lt;:AbstractFESet}</code></pre><p>Set the labels of individual elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.setlabel!-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.setlabel!-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.setlabel!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setlabel!(self::T, val::FInt) where {T&lt;:AbstractFESet}</code></pre><p>Set the label of the entire finite elements set.</p><p>All elements are labeled with this number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L182-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.subset-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.subset-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.subset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">subset(self::T, L::FIntVec) where {T&lt;:AbstractFESet}</code></pre><p>Extract a subset of the finite elements from the given finite element set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FESetModule.updateconn!-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T&lt;:AbstractFESet" href="#FinEtools.FESetModule.updateconn!-Union{Tuple{T}, Tuple{T,Array{Int64,1}}} where T&lt;:AbstractFESet"><code>FinEtools.FESetModule.updateconn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateconn!(self::T, newids::FIntVec) where {T&lt;:AbstractFESet}</code></pre><p>Update the connectivity after the IDs of nodes changed.</p><p><code>newids</code>= new node IDs. Note that indexes in the conn array &quot;point&quot; <em>into</em> the  <code>newids</code> array. After the connectivity was updated this will no longer be true!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FESetModule.jl#L233-L241">source</a></section></article><h2 id="Finite-element-nodes-1"><a class="docs-heading-anchor" href="#Finite-element-nodes-1">Finite element nodes</a><a class="docs-heading-anchor-permalink" href="#Finite-element-nodes-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.count-Tuple{FENodeSet}" href="#Base.count-Tuple{FENodeSet}"><code>Base.count</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">count(self::FENodeSet)</code></pre><p>Get the number of finite element nodes in the node set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FENodeSetModule.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeSetModule.spacedim-Tuple{FENodeSet}" href="#FinEtools.FENodeSetModule.spacedim-Tuple{FENodeSet}"><code>FinEtools.FENodeSetModule.spacedim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spacedim(self::FENodeSet)</code></pre><p>Number of dimensions of the space in which the node lives, 1, 2, or 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FENodeSetModule.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FENodeSetModule.xyz3-Tuple{FENodeSet}" href="#FinEtools.FENodeSetModule.xyz3-Tuple{FENodeSet}"><code>FinEtools.FENodeSetModule.xyz3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xyz3(self::FENodeSet)</code></pre><p>Get the  3-D coordinate that define the location  of the node. Even if the nodes  were specified in  lower dimension (1-D, 2-D) this function returns  a 3-D coordinate  by padding with zeros.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FENodeSetModule.jl#L37-L43">source</a></section></article><h2 id="Finite-element-node-to-element-map-1"><a class="docs-heading-anchor" href="#Finite-element-node-to-element-map-1">Finite element node-to-element map</a><a class="docs-heading-anchor-permalink" href="#Finite-element-node-to-element-map-1" title="Permalink"></a></h2><h2 id="Selecting-nodes-and-elements-1"><a class="docs-heading-anchor" href="#Selecting-nodes-and-elements-1">Selecting nodes and elements</a><a class="docs-heading-anchor-permalink" href="#Selecting-nodes-and-elements-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.connectedelems-Tuple{AbstractFESet,Array{Int64,1},Int64}" href="#FinEtools.MeshSelectionModule.connectedelems-Tuple{AbstractFESet,Array{Int64,1},Int64}"><code>FinEtools.MeshSelectionModule.connectedelems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connectedelems(fes::AbstractFESet, node_list::FIntVec)</code></pre><p>Extract the list of numbers for the fes  that are connected to given nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshSelectionModule.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.connectednodes-Tuple{AbstractFESet}" href="#FinEtools.MeshSelectionModule.connectednodes-Tuple{AbstractFESet}"><code>FinEtools.MeshSelectionModule.connectednodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connectednodes(fes::AbstractFESet)</code></pre><p>Extract the node numbers of the nodes connected by given finite elements.</p><p>Extract the list of unique node numbers for the nodes that are connected by the finite element set <code>fes</code>. Note that it is assumed that all the FEs are of the same type (the same number of connected nodes by each cell).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshSelectionModule.jl#L16-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.findunconnnodes-Tuple{FENodeSet,AbstractFESet}" href="#FinEtools.MeshSelectionModule.findunconnnodes-Tuple{FENodeSet,AbstractFESet}"><code>FinEtools.MeshSelectionModule.findunconnnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findunconnnodes(fens::FENodeSet, fes::AbstractFESet)</code></pre><p>Find nodes that are not connected to any finite element.</p><p>connected = array is returned which is for the node k either true (node k is      connected), or false (node k is not connected).</p><p>Let us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshSelectionModule.jl#L612-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.selectelem-Union{Tuple{T}, Tuple{FENodeSet,T}} where T&lt;:AbstractFESet" href="#FinEtools.MeshSelectionModule.selectelem-Union{Tuple{T}, Tuple{FENodeSet,T}} where T&lt;:AbstractFESet"><code>FinEtools.MeshSelectionModule.selectelem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">selectelem(fens::FENodeSet, fes::T; kwargs...) where {T&lt;:AbstractFESet}</code></pre><p>Select finite elements.</p><p><strong>Arguments</strong></p><ul><li><code>fens</code> = finite element node set</li><li><code>fes</code> = finite element set</li><li><code>kwargs</code> = keyword arguments to specify the selection criteria</li></ul><p><strong>Selection criteria</strong></p><p><strong>facing</strong></p><p>Select all &quot;boundary&quot; elements that &quot;face&quot; a certain direction.</p><pre><code class="language-none">exteriorbfl = selectelem(fens, bdryfes, facing=true, direction=[1.0, 1.0, 0.0]);</code></pre><p>or</p><pre><code class="language-none">exteriorbfl = selectelem(fens, bdryfes, facing=true, direction=dout, dotmin = 0.99);</code></pre><p>where</p><pre><code class="language-none">function dout(xyz)
    return xyz/norm(xyz)
end</code></pre><p>and <code>xyz</code> is the location of the centroid  of  a boundary element. Here the finite element is considered &quot;facing&quot; in the given direction if the dot product of its normal and the direction vector is greater than <code>dotmin</code>. The default value for <code>dotmin</code> is 0.01 (this corresponds to  almost 90 degrees between the normal to the finite element  and the given direction).</p><p>This selection method makes sense only for elements that are  surface-like (i. e. for boundary mmeshes).</p><p><strong>label</strong></p><p>Select elements based on their label.</p><pre><code class="language-none">rl1 = selectelem(fens, fes, label=1)</code></pre><p><strong>box, distance</strong></p><p>Select elements based on some criteria that their nodes satisfy.  See the function <code>selectnode()</code>.</p><p>Example: Select all  elements whose nodes are closer than <code>R+inflate</code> from the point <code>from</code>.</p><pre><code class="language-none">linner = selectelem(fens, bfes, distance = R, from = [0.0 0.0 0.0],
  inflate = tolerance)</code></pre><p>Example:</p><pre><code class="language-none">exteriorbfl = selectelem(fens, bdryfes,
   box=[1.0, 1.0, 0.0, pi/2, 0.0, Thickness], inflate=tolerance);</code></pre><p><strong>flood</strong></p><p>Select all FEs connected together, starting from a given node.</p><p>Example: Select all FEs connected together (Starting from node 13):</p><pre><code class="language-julia">l = selectelem(fens, fes, flood = true, startnode = 13)</code></pre><p><strong>Optional keyword arguments</strong></p><p>Should we consider the element only if all its nodes are in?</p><ul><li><code>allin</code> = Boolean: if true, then all nodes of an element must satisfy</li></ul><p>the criterion; otherwise  one is enough.</p><p><strong>Output</strong></p><p><code>felist</code> = list of finite elements from the set that satisfy the criteria</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshSelectionModule.jl#L95-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.selectnode-Tuple{FENodeSet}" href="#FinEtools.MeshSelectionModule.selectnode-Tuple{FENodeSet}"><code>FinEtools.MeshSelectionModule.selectnode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">selectnode(fens::FENodeSet; kwargs...)</code></pre><p>Select nodes using some criterion.</p><p><strong>Arguments</strong></p><ul><li><code>v</code> = array of locations, one location per row</li><li><code>kwargs</code> = pairs of keyword argument/value</li></ul><p><strong>Selection criteria</strong></p><p><strong>box</strong></p><pre><code class="language-none">nLx = vselect(fens.xyz, box = [0.0 Lx  0.0 0.0 0.0 0.0], inflate = Lx/1.0e5)</code></pre><p>The keyword &#39;inflate&#39; may be used to increase or decrease the extent of the box (or the distance) to make sure some nodes which would be on the boundary are either excluded or included.</p><p><strong>distance</strong></p><pre><code class="language-none">list = selectnode(fens.xyz, distance=1.0+0.1/2^nref, from=[0. 0.],
        inflate=tolerance);</code></pre><p><strong>plane</strong></p><pre><code class="language-none">candidates = selectnode(fens, plane = [0.0 0.0 1.0 0.0], thickness = h/1000)</code></pre><p>The keyword <code>plane</code> defines the plane by its normal (the first two or three numbers) and its distance from the origin (the last number). Nodes are selected they lie on the plane,  or near the plane within the distance <code>thickness</code> from the plane. The normal is assumed to be of unit length, if it isn&#39;t apply as such, it will be normalized internally.</p><p><strong>nearestto</strong></p><p>Find the node nearest to the location given.</p><pre><code class="language-none">nh = selectnode(fens, nearestto = [R+Ro/2, 0.0, 0.0] )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshSelectionModule.jl#L47-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshSelectionModule.vselect-Tuple{Array{Float64,2}}" href="#FinEtools.MeshSelectionModule.vselect-Tuple{Array{Float64,2}}"><code>FinEtools.MeshSelectionModule.vselect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vselect(v::FFltMat; kwargs...)</code></pre><p>Select locations (vertices) from the array based on some criterion.</p><p>See the function <code>selectnode()</code> for examples of the criteria that can be used to search vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshSelectionModule.jl#L518-L525">source</a></section></article><h2 id="Fields-1"><a class="docs-heading-anchor" href="#Fields-1">Fields</a><a class="docs-heading-anchor-permalink" href="#Fields-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Union{Tuple{F}, Tuple{F,F}} where F&lt;:AbstractField" href="#Base.copyto!-Union{Tuple{F}, Tuple{F,F}} where F&lt;:AbstractField"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">copyto!(DEST::F,  SRC::F) where {F&lt;:AbstractField}</code></pre><p>Copy data from one field to another.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.applyebc!-Tuple{AbstractField}" href="#FinEtools.FieldModule.applyebc!-Tuple{AbstractField}"><code>FinEtools.FieldModule.applyebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">applyebc!(self::AbstractField)</code></pre><p>Apply EBCs (essential boundary conditions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L504-L508">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gatherdofnums!-Union{Tuple{CC}, Tuple{A}, Tuple{AbstractField,A,CC}} where CC where A" href="#FinEtools.FieldModule.gatherdofnums!-Union{Tuple{CC}, Tuple{A}, Tuple{AbstractField,A,CC}} where CC where A"><code>FinEtools.FieldModule.gatherdofnums!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gatherdofnums!(self::AbstractField, dest::A, conn::CC) where {A, CC}</code></pre><p>Gather dofnums from the field.</p><p>The order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom for that node,  then the next node  and so on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L245-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gatherfixedvalues_asmat!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,2},CC}} where T where CC" href="#FinEtools.FieldModule.gatherfixedvalues_asmat!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,2},CC}} where T where CC"><code>FinEtools.FieldModule.gatherfixedvalues_asmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gatherfixedvalues_asmat!(self::AbstractField, dest::AbstractArray{T, 2},
    conn::CC) where {CC, T}</code></pre><p>Gather FIXED values from the field into a two-dimensional array.</p><p>The order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.  If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L205-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gatherfixedvalues_asvec!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,1},CC}} where T where CC" href="#FinEtools.FieldModule.gatherfixedvalues_asvec!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,1},CC}} where T where CC"><code>FinEtools.FieldModule.gatherfixedvalues_asvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gatherfixedvalues_asvec!(self::AbstractField, dest::AbstractArray{T, 1},
    conn::CC) where {CC, T}</code></pre><p>Gather FIXED values from the field into a vector.</p><p>The order is: for each node  in the connectivity, copy into the buffer all the fixed degrees of freedom,  then the next node and so on. If a degree of freedom is NOT fixed, the corresponding entry is  set to zero.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L176-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gathersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F,Array{T,1}}} where T where F&lt;:AbstractField" href="#FinEtools.FieldModule.gathersysvec!-Union{Tuple{T}, Tuple{F}, Tuple{F,Array{T,1}}} where T where F&lt;:AbstractField"><code>FinEtools.FieldModule.gathersysvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gathersysvec!(self::F, vec::FVec{T}) where {F&lt;:AbstractField, T}</code></pre><p>Gather values from the field for the whole system vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gathersysvec-Union{Tuple{F}, Tuple{F}} where F&lt;:AbstractField" href="#FinEtools.FieldModule.gathersysvec-Union{Tuple{F}, Tuple{F}} where F&lt;:AbstractField"><code>FinEtools.FieldModule.gathersysvec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gathersysvec{F&lt;:AbstractField}(self::F)</code></pre><p>Gather values from the field for the whole system vector. Return a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gathervalues_asmat!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,2},CC}} where T where CC" href="#FinEtools.FieldModule.gathervalues_asmat!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,2},CC}} where T where CC"><code>FinEtools.FieldModule.gathervalues_asmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gathervalues_asmat!(self::AbstractField, dest::AbstractArray{T, 2},
    conn::CC) where {CC, T}</code></pre><p>Gather values from the field into a two-dimensional array.</p><p>The order is: for each node  in the connectivity, copy into the corresponding row of the buffer all the degrees of freedom,  then the next node into the next row and so on.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L154-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.gathervalues_asvec!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,1},CC}} where T where CC" href="#FinEtools.FieldModule.gathervalues_asvec!-Union{Tuple{T}, Tuple{CC}, Tuple{AbstractField,AbstractArray{T,1},CC}} where T where CC"><code>FinEtools.FieldModule.gathervalues_asvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gathervalues_asvec!(self::AbstractField, dest::AbstractArray{T, 1},
    conn::CC) where {CC, T}</code></pre><p>Gather values from the field into a vector.</p><p>The order is: for each node  in the connectivity, copy into the buffer all the degrees of freedom,  then the next node and so on.</p><p><code>dest</code> = destination buffer: overwritten  inside,  must be preallocated in the correct size</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L130-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.incrscattersysvec!-Union{Tuple{T}, Tuple{AbstractField,Array{T,1}}} where T&lt;:Number" href="#FinEtools.FieldModule.incrscattersysvec!-Union{Tuple{T}, Tuple{AbstractField,Array{T,1}}} where T&lt;:Number"><code>FinEtools.FieldModule.incrscattersysvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">incrscattersysvec!(self::AbstractField, vec::FVec{T}) where {T&lt;:Number}</code></pre><p>Increment values of the field by scattering a system vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L539-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.ndofs-Tuple{AbstractField}" href="#FinEtools.FieldModule.ndofs-Tuple{AbstractField}"><code>FinEtools.FieldModule.ndofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ndofs{F&lt;:AbstractField}(self::T)</code></pre><p>Dimension of the degree of freedom parameters (i. e. how many degrees of freedom per entity).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.nents-Tuple{AbstractField}" href="#FinEtools.FieldModule.nents-Tuple{AbstractField}"><code>FinEtools.FieldModule.nents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nents{F&lt;:AbstractField}(self::F)</code></pre><p>Number of nodes associated with the field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.numberdofs!-Tuple{AbstractField}" href="#FinEtools.FieldModule.numberdofs!-Tuple{AbstractField}"><code>FinEtools.FieldModule.numberdofs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">numberdofs!(self::AbstractField)</code></pre><p>Number the degrees of freedom.</p><p>The free components in the field are numbered consecutively. No effort is made to optimize the numbering in any way. If you&#39;d like to optimize the numbering of the degrees of freedom, use the above form that sets the permutation of the degrees of freedom, or the permutation of the nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L264-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.prescribeddofs-Tuple{AbstractField,AbstractField}" href="#FinEtools.FieldModule.prescribeddofs-Tuple{AbstractField,AbstractField}"><code>FinEtools.FieldModule.prescribeddofs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prescribeddofs(uebc, u)</code></pre><p>Find which degrees of freedom are prescribed. <code>uebc</code> = field which defines the constraints (is the dof fixed and to which value), <code>u</code> = field which does not have the constraints applied, and serves as the source of equation numbers, <code>uebc</code> and <code>u</code> may be one and the same field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L557-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.scattersysvec!-Union{Tuple{T}, Tuple{AbstractField,Array{T,1}}} where T&lt;:Number" href="#FinEtools.FieldModule.scattersysvec!-Union{Tuple{T}, Tuple{AbstractField,Array{T,1}}} where T&lt;:Number"><code>FinEtools.FieldModule.scattersysvec!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scattersysvec!(self::AbstractField, vec::FVec{T}) where {T&lt;:Number}</code></pre><p>Scatter values to the field from a system vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L521-L525">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Tuple{AbstractField,Array{Int64,1}}" href="#FinEtools.FieldModule.setebc!-Tuple{AbstractField,Array{Int64,1}}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setebc!(self::AbstractField, fenids::FIntVec)</code></pre><p>Set the EBCs (essential boundary conditions).</p><p>Suppress all degrees of freedom at the given nodes.</p><p><code>fenids</code>         - array of N node identifiers</p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L442-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Tuple{AbstractField,Int64}" href="#FinEtools.FieldModule.setebc!-Tuple{AbstractField,Int64}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setebc!(self::AbstractField, fenid::FInt)</code></pre><p>Set the EBCs (essential boundary conditions).</p><p>Suppress all degrees of freedom at the given node.</p><p><code>fenid</code>         - One integer as a node identifier</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L464-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Tuple{AbstractField}" href="#FinEtools.FieldModule.setebc!-Tuple{AbstractField}"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setebc!(self::AbstractField)</code></pre><p>Set the EBCs (essential boundary conditions).</p><p>All essential boundary conditions are CLEARED.</p><p>Note:  Any call to setebc!() potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L483-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Array{Int64,1}}, Tuple{AbstractField,Array{Int64,1},Bool,Array{Int64,1},T}} where T&lt;:Number" href="#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Array{Int64,1}}, Tuple{AbstractField,Array{Int64,1},Bool,Array{Int64,1},T}} where T&lt;:Number"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setebc!(self::AbstractField, fenids::FIntVec, is_fixed::Bool, comp::FIntVec, val::T=0.0) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code> = array of N node identifiers <code>comp</code> = integer vector, which degree of freedom (component), <code>val</code> = scalar of type <code>T</code>, default is <code>0.0</code></p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L421-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Int64,Array{T,1}}} where T&lt;:Number" href="#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Int64,Array{T,1}}} where T&lt;:Number"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setebc!(self::AbstractField, fenids::FIntVec, is_fixed::Bool, comp::FInt,
  val::FVec{T}) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>is_fixed</code> = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = array of N values of type T</p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L326-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Int64}, Tuple{AbstractField,Array{Int64,1},Bool,Int64,T}} where T&lt;:Number" href="#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Bool,Int64}, Tuple{AbstractField,Array{Int64,1},Bool,Int64,T}} where T&lt;:Number"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setebc!(self::AbstractField, fenids::FIntVec, is_fixed::Bool, comp::FInt, val::T = 0.0) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>is_fixed</code> = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = scalar of type T</p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L355-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Int64,Array{T,1}}} where T&lt;:Number" href="#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Int64,Array{T,1}}} where T&lt;:Number"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setebc!(self::AbstractField, fenids::FIntVec, comp::FInt,
  val::FVec{T}) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code> = array of N node identifiers <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = array of N values of type <code>T</code></p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L383-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Int64}, Tuple{AbstractField,Array{Int64,1},Int64,T}} where T&lt;:Number" href="#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Array{Int64,1},Int64}, Tuple{AbstractField,Array{Int64,1},Int64,T}} where T&lt;:Number"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setebc!(self::AbstractField, fenids::FIntVec, comp::FInt, val::T=0.0) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code> = array of N node identifiers <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = scalar of type <code>T</code></p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L403-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Int64,Bool,Int64,T}} where T&lt;:Number" href="#FinEtools.FieldModule.setebc!-Union{Tuple{T}, Tuple{AbstractField,Int64,Bool,Int64,T}} where T&lt;:Number"><code>FinEtools.FieldModule.setebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setebc!(self::AbstractField, fenid::FInt, is_fixed::Bool, comp::FInt, val::T) where {T&lt;:Number}</code></pre><p>Set the EBCs (essential boundary conditions).</p><p><code>fenids</code>         - array of N node identifiers <code>is_fixed</code> = scaler Boolean: are the degrees of freedom being fixed (true)              or released (false), <code>comp</code> = integer, which  degree of freedom (component), <code>val</code> = array of N values of type T</p><p>Note:  Any call to <code>setebc!()</code> potentially changes the current assignment which degrees of freedom are free and which are fixed and therefore is presumed to invalidate the current degree-of-freedom numbering. In such a case this method sets <code>nfreedofs = 0</code>; and  <code>dofnums=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L301-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FieldModule.wipe!-Tuple{AbstractField}" href="#FinEtools.FieldModule.wipe!-Tuple{AbstractField}"><code>FinEtools.FieldModule.wipe!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wipe!(self::AbstractField)</code></pre><p>Wipe all the data from the field.</p><p>This includes values, prescribed values, degree of freedom numbers, and &quot;is fixed&quot; flags. The number of free degrees of freedom is set to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FieldModule.jl#L73-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.NodalFieldModule.nnodes-Tuple{NodalField}" href="#FinEtools.NodalFieldModule.nnodes-Tuple{NodalField}"><code>FinEtools.NodalFieldModule.nnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nnodes(self::NodalField)::FInt = nents(self)</code></pre><p>Provide the number of nodes  in the nodal field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/NodalFieldModule.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ElementalFieldModule.nelems-Tuple{ElementalField}" href="#FinEtools.ElementalFieldModule.nelems-Tuple{ElementalField}"><code>FinEtools.ElementalFieldModule.nelems</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nelems(self::ElementalField)::FInt = nents(self)</code></pre><p>Provide the number of elements  in the elemental field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/ElementalFieldModule.jl#L53-L57">source</a></section></article><h2 id="Integration-rule-1"><a class="docs-heading-anchor" href="#Integration-rule-1">Integration rule</a><a class="docs-heading-anchor-permalink" href="#Integration-rule-1" title="Permalink"></a></h2><h2 id="Integration-domain-1"><a class="docs-heading-anchor" href="#Integration-domain-1">Integration domain</a><a class="docs-heading-anchor-permalink" href="#Integration-domain-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet0Manifold" href="#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet0Manifold"><code>FinEtools.IntegDomainModule.Jacobiancurve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobiancurve(self::IntegDomain{T}, J::FFltMat,
    loc::FFltMat, conn::CC,
    N::FFltMat)::FFlt where {T&lt;:AbstractFESet0Manifold, CC}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L119-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet1Manifold" href="#FinEtools.IntegDomainModule.Jacobiancurve-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet1Manifold"><code>FinEtools.IntegDomainModule.Jacobiancurve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobiancurve(self::IntegDomain{T}, J::FFltMat,
          loc::FFltMat, conn::CC,
          N::FFltMat)::FFlt where {T&lt;:AbstractFESet1Manifold, CC}</code></pre><p>Evaluate the curve Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L221-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T&lt;:AbstractFESet0Manifold" href="#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T&lt;:AbstractFESet0Manifold"><code>FinEtools.IntegDomainModule.Jacobianmdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobianmdim(self::IntegDomain{T}, J::FFltMat,
  loc::FFltMat, conn::CC,
  N::FFltMat, m::FInt)::FFlt where {T&lt;:AbstractFESet0Manifold, CC}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 0-dimensional finite element,  the manifold Jacobian is for</p><ul><li>m=0: +1</li><li>m=1: <code>Jacobiancurve</code></li><li>m=2: <code>Jacobiansurface</code></li><li>m=3: <code>Jacobianvolume</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L194-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T&lt;:AbstractFESet1Manifold" href="#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T&lt;:AbstractFESet1Manifold"><code>FinEtools.IntegDomainModule.Jacobianmdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobianmdim(self::IntegDomain{T}, J::FFltMat,
loc::FFltMat, conn::CC,
N::FFltMat, m::FInt)::FFlt where {T&lt;:AbstractFESet1Manifold, CC}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 1-dimensional finite element,  the manifold Jacobian is for</p><ul><li>m=1: <code>Jacobiancurve</code></li><li>m=2: <code>Jacobiansurface</code></li><li>m=3: <code>Jacobianvolume</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L290-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T&lt;:AbstractFESet2Manifold" href="#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T&lt;:AbstractFESet2Manifold"><code>FinEtools.IntegDomainModule.Jacobianmdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobianmdim(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat, m::FInt)::FFlt where {T&lt;:AbstractFESet2Manifold, CC}</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 2-dimensional finite element,  the manifold Jacobian is for</p><ul><li>m=2: <code>Jacobiansurface</code></li><li>m=3: <code>Jacobianvolume</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L356-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T&lt;:AbstractFESet3Manifold" href="#FinEtools.IntegDomainModule.Jacobianmdim-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2},Int64}} where CC where T&lt;:AbstractFESet3Manifold"><code>FinEtools.IntegDomainModule.Jacobianmdim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobianmdim{T&lt;:AbstractFESet3Manifold}(self::IntegDomain, J::FFltMat,
            loc::FFltMat, conn::FIntMat, N::FFltMat, m::FInt)</code></pre><p>Evaluate the manifold Jacobian for an m-dimensional manifold.</p><p>For an 3-dimensional cell,  the manifold Jacobian is</p><ul><li>m=3: <code>Jacobianvolume</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L392-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianpoint-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet0Manifold" href="#FinEtools.IntegDomainModule.Jacobianpoint-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet0Manifold"><code>FinEtools.IntegDomainModule.Jacobianpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobianpoint(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:AbstractFESet0Manifold, CC}</code></pre><p>Evaluate the point Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L103-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet0Manifold" href="#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet0Manifold"><code>FinEtools.IntegDomainModule.Jacobiansurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobiansurface(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:AbstractFESet0Manifold, CC}</code></pre><p>Evaluate the surface Jacobian.</p><p>For the zero-dimensional cell, the surface Jacobian is (i) the product of the point Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point <code>loc</code> times the other dimension (units of length).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L140-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet1Manifold" href="#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet1Manifold"><code>FinEtools.IntegDomainModule.Jacobiansurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobiansurface(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:AbstractFESet1Manifold, CC}</code></pre><p>Evaluate the surface Jacobian.</p><p>For the one-dimensional cell,  the surface Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point <code>loc</code>.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L237-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet2Manifold" href="#FinEtools.IntegDomainModule.Jacobiansurface-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet2Manifold"><code>FinEtools.IntegDomainModule.Jacobiansurface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobiansurface(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
             N::FFltMat)::FFlt where {T&lt;:AbstractFESet2Manifold, CC}</code></pre><p>Evaluate the surface Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L314-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet0Manifold" href="#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet0Manifold"><code>FinEtools.IntegDomainModule.Jacobianvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobianvolume(self::IntegDomain{T}, J::FFltMat,
      loc::FFltMat, conn::CC,
      N::FFltMat)::FFlt where {T&lt;:AbstractFESet0Manifold, CC}</code></pre><p>Evaluate the volume Jacobian.</p><p>For the zero-dimensional cell, the volume Jacobian is (i) the product of the point Jacobian and the other dimension (units of length cubed); or,  when used as axially symmetric (ii) the product of the point Jacobian and the circumference of the circle through the point <code>loc</code> and the other dimension (units of length squared).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L167-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet1Manifold" href="#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet1Manifold"><code>FinEtools.IntegDomainModule.Jacobianvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobianvolume(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:AbstractFESet1Manifold, CC}</code></pre><p>Evaluate the volume Jacobian.</p><p>For the one-dimensional cell,  the volume Jacobian is (i) the product of the curve Jacobian and the other dimension (units of length squared); or,  when used as axially symmetric (ii) the product of the curve Jacobian and the circumference of the circle through the point <code>loc</code> and the other dimension (units of length).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L263-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet2Manifold" href="#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet2Manifold"><code>FinEtools.IntegDomainModule.Jacobianvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobianvolume(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:AbstractFESet2Manifold, CC}</code></pre><p>Evaluate the volume Jacobian.</p><p>For the two-dimensional cell,  the volume Jacobian is (i) the product of the surface Jacobian and the other dimension (units of length); or,  when used as axially symmetric (ii) the product of the surface Jacobian and the circumference of the circle through the point <code>loc</code> (units of length).</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L330-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet3Manifold" href="#FinEtools.IntegDomainModule.Jacobianvolume-Union{Tuple{CC}, Tuple{T}, Tuple{IntegDomain{T,F} where F&lt;:Function,Array{Float64,2},Array{Float64,2},CC,Array{Float64,2}}} where CC where T&lt;:AbstractFESet3Manifold"><code>FinEtools.IntegDomainModule.Jacobianvolume</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jacobianvolume(self::IntegDomain{T}, J::FFltMat,
            loc::FFltMat, conn::CC,
            N::FFltMat)::FFlt where {T&lt;:AbstractFESet3Manifold, CC}</code></pre><p>Evaluate the volume Jacobian.</p><ul><li><code>J</code> = Jacobian matrix</li><li><code>loc</code> = location of the quadrature point in physical coordinates,</li><li><code>conn</code> = connectivity of the element,</li><li><code>N</code> = matrix of basis function values at the quadrature point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L377-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.integrationdata-Tuple{IntegDomain}" href="#FinEtools.IntegDomainModule.integrationdata-Tuple{IntegDomain}"><code>FinEtools.IntegDomainModule.integrationdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrationdata(self::IntegDomain)</code></pre><p>Calculate the data needed for  numerical quadrature for the integration rule stored by the integration domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L406-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.integrationdata-Union{Tuple{T}, Tuple{IntegDomain,T}} where T&lt;:AbstractIntegRule" href="#FinEtools.IntegDomainModule.integrationdata-Union{Tuple{T}, Tuple{IntegDomain,T}} where T&lt;:AbstractIntegRule"><code>FinEtools.IntegDomainModule.integrationdata</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrationdata(self::IntegDomain, integration_rule::T) where {T&lt;:AbstractIntegRule}</code></pre><p>Calculate the data needed for numerical quadrature.</p><p>For given integration domain, compute the quantities needed for numerical integration.</p><p><strong>Return</strong></p><p><code>npts</code>, <code>Ns</code>, <code>gradNparams</code>, <code>w</code>, <code>pc</code> = number of quadrature points, arrays of basis function values at the quadrature points,  arrays of gradients of basis functions  with respect  to the parametric coordinates, array of weights and array of locations of the quadrature points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L417-L430">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.IntegDomainModule.otherdimensionunity-Union{Tuple{CC}, Tuple{Array{Float64,2},CC,Array{Float64,2}}} where CC" href="#FinEtools.IntegDomainModule.otherdimensionunity-Union{Tuple{CC}, Tuple{Array{Float64,2},CC,Array{Float64,2}}} where CC"><code>FinEtools.IntegDomainModule.otherdimensionunity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">otherdimensionunity(loc::FFltMat, conn::CC, N::FFltMat)::FFlt
          where {CC}</code></pre><p>Evaluate the other dimension: default is 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/IntegDomainModule.jl#L93-L98">source</a></section></article><h2 id="Assembly-of-matrices-and-vectors-1"><a class="docs-heading-anchor" href="#Assembly-of-matrices-and-vectors-1">Assembly of matrices and vectors</a><a class="docs-heading-anchor-permalink" href="#Assembly-of-matrices-and-vectors-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{D}, Tuple{MV}, Tuple{T}, Tuple{SV}, Tuple{SV,MV,D}} where D&lt;:(AbstractArray{Int64,N} where N) where MV&lt;:(AbstractArray{T,N} where N) where T&lt;:Number where SV&lt;:AbstractSysvecAssembler" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{D}, Tuple{MV}, Tuple{T}, Tuple{SV}, Tuple{SV,MV,D}} where D&lt;:(AbstractArray{Int64,N} where N) where MV&lt;:(AbstractArray{T,N} where N) where T&lt;:Number where SV&lt;:AbstractSysvecAssembler"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(self::SysvecAssembler{T}, vec::MV,
  dofnums::D) where {T&lt;:Number, MV&lt;:AbstractArray{T}, D&lt;:AbstractArray{FInt}}</code></pre><p>Assemble an elementwise vector.</p><p>The method assembles a column element vector using the vector of degree of freedom numbers for the rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L314-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{D}, Tuple{MV}, Tuple{T}, Tuple{SysvecAssembler{T},MV,D}} where D&lt;:(AbstractArray{Int64,N} where N) where MV&lt;:(AbstractArray{T,N} where N) where T&lt;:Number" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{D}, Tuple{MV}, Tuple{T}, Tuple{SysvecAssembler{T},MV,D}} where D&lt;:(AbstractArray{Int64,N} where N) where MV&lt;:(AbstractArray{T,N} where N) where T&lt;:Number"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(self::SysvecAssembler{T}, vec::MV,
  dofnums::D) where {T&lt;:Number, MV&lt;:AbstractArray{T}, D&lt;:AbstractArray{FInt}}</code></pre><p>Assemble an elementwise vector.</p><p>The method assembles a column element vector using the vector of degree of freedom numbers for the rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L369-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T&lt;:Number" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T&lt;:Number"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(self::SysmatAssemblerSparseHRZLumpingSymm{T}, mat::FMat{T},
  dofnums::FIntMat, ignore::FIntMat) where {T&lt;:Number}</code></pre><p>Assemble a HRZ-lumped square symmetric matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L454-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Array{T,2},Array{Int64,2},Array{Int64,2}}} where T&lt;:Number" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Array{T,2},Array{Int64,2},Array{Int64,2}}} where T&lt;:Number"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(self::SysmatAssemblerSparseHRZLumpingSymm{T}, mat::FMat{T},
    dofnums::FIntMat, ignore::FIntMat) where {T&lt;:Number}</code></pre><p>Assemble an HRZ-lumped square symmetric matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L485-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T&lt;:Number" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T&lt;:Number"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(self::SysmatAssemblerSparseSymm{T}, mat::FMat{T},  dofnums::FIntVec, ignore::FIntVec) where {T&lt;:Number}</code></pre><p>Assemble a square symmetric matrix.</p><p><code>dofnums</code> are the row degree of freedom numbers, the column degree of freedom number input is ignored (the row and column numbers are the same).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L219-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Array{T,2},Array{Int64,2},Array{Int64,2}}} where T&lt;:Number" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Array{T,2},Array{Int64,2},Array{Int64,2}}} where T&lt;:Number"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(self::SysmatAssemblerSparseSymm{T}, mat::FMat{T},
  dofnums::FIntMat, ignore::FIntMat) where {T&lt;:Number}</code></pre><p>Assemble a square symmetric matrix.</p><p><code>dofnums</code> are the row degree of freedom numbers, the column degree of freedom number input is ignored (the row and column numbers are the same).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L247-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparse{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T&lt;:Number" href="#FinEtools.AssemblyModule.assemble!-Union{Tuple{T}, Tuple{SysmatAssemblerSparse{T},Array{T,2},Array{Int64,1},Array{Int64,1}}} where T&lt;:Number"><code>FinEtools.AssemblyModule.assemble!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assemble!(self::SysmatAssemblerSparse{T}, mat::FMat{T},
  dofnums_row::FIntMat, dofnums_col::FIntMat) where {T&lt;:Number}</code></pre><p>Assemble a rectangular matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseHRZLumpingSymm}" href="#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseHRZLumpingSymm}"><code>FinEtools.AssemblyModule.makematrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makematrix!(self::SysmatAssemblerSparseHRZLumpingSymm)</code></pre><p>Make a sparse HRZ-lumped <strong>symmetric square</strong>  matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L495-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseSymm}" href="#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparseSymm}"><code>FinEtools.AssemblyModule.makematrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makematrix!(self::SysmatAssemblerSparseSymm)</code></pre><p>Make a sparse symmetric square matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L260-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparse}" href="#FinEtools.AssemblyModule.makematrix!-Tuple{SysmatAssemblerSparse}"><code>FinEtools.AssemblyModule.makematrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makematrix!(self::SysmatAssemblerSparse)</code></pre><p>Make a sparse matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L119-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makevector!-Tuple{SysvecAssembler}" href="#FinEtools.AssemblyModule.makevector!-Tuple{SysvecAssembler}"><code>FinEtools.AssemblyModule.makevector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makevector!(self::SysvecAssembler)</code></pre><p>Make the global vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L388-L392">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.makevector!-Union{Tuple{SV}, Tuple{SV}} where SV&lt;:AbstractSysvecAssembler" href="#FinEtools.AssemblyModule.makevector!-Union{Tuple{SV}, Tuple{SV}} where SV&lt;:AbstractSysvecAssembler"><code>FinEtools.AssemblyModule.makevector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makevector!(self::SysvecAssembler)</code></pre><p>Make the global vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L326-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SV}, Tuple{SV,Int64}} where T&lt;:Number where SV&lt;:AbstractSysvecAssembler" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SV}, Tuple{SV,Int64}} where T&lt;:Number where SV&lt;:AbstractSysvecAssembler"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">startassembly!(self::SysvecAssembler{T},
  ndofs_row::FInt) where {T&lt;:Number}</code></pre><p>Start assembly.</p><p>The method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.</p><p><code>ndofs_row</code>= Total number of degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L300-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Int64,Int64,Int64,Int64,Int64}} where T&lt;:Number" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseHRZLumpingSymm{T},Int64,Int64,Int64,Int64,Int64}} where T&lt;:Number"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">startassembly!(self::SysmatAssemblerSparseHRZLumpingSymm{T},
  elem_mat_dim::FInt, ignore1::FInt, elem_mat_nmatrices::FInt,
  ndofs::FInt, ignore2::FInt) where {T&lt;:Number}</code></pre><p>Start the assembly of a symmetric lumped square global matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L429-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Int64,Int64,Int64,Int64,Int64}} where T&lt;:Number" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparseSymm{T},Int64,Int64,Int64,Int64,Int64}} where T&lt;:Number"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">startassembly!(self::SysmatAssemblerSparseSymm{T},
  elem_mat_dim::FInt, ignore1::FInt, elem_mat_nmatrices::FInt,
  ndofs::FInt, ignore2::FInt) where {T&lt;:Number}</code></pre><p>Start the assembly of a symmetric square global matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L192-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparse{T},Int64,Int64,Int64,Int64,Int64}} where T&lt;:Number" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysmatAssemblerSparse{T},Int64,Int64,Int64,Int64,Int64}} where T&lt;:Number"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">startassembly!(self::SysmatAssemblerSparse{T},
  elem_mat_nrows::FInt, elem_mat_ncols::FInt, elem_mat_nmatrices::FInt,
  ndofs_row::FInt, ndofs_col::FInt) where {T&lt;:Number}</code></pre><p>Start the assembly of a global matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L61-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysvecAssembler{T},Int64}} where T&lt;:Number" href="#FinEtools.AssemblyModule.startassembly!-Union{Tuple{T}, Tuple{SysvecAssembler{T},Int64}} where T&lt;:Number"><code>FinEtools.AssemblyModule.startassembly!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">startassembly!(self::SysvecAssembler{T},
  ndofs_row::FInt) where {T&lt;:Number}</code></pre><p>Start assembly.</p><p>The method makes the buffer for the vector assembly. It must be called before the first call to the method assemble.</p><p><code>ndofs_row</code>= Total number of degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AssemblyModule.jl#L353-L363">source</a></section></article><h2 id="Meshing-1"><a class="docs-heading-anchor" href="#Meshing-1">Meshing</a><a class="docs-heading-anchor-permalink" href="#Meshing-1" title="Permalink"></a></h2><h3 id="Meshing-with-line-elements-1"><a class="docs-heading-anchor" href="#Meshing-with-line-elements-1">Meshing with line elements</a><a class="docs-heading-anchor-permalink" href="#Meshing-with-line-elements-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshLineModule.L2block-Tuple{Float64,Int64}" href="#FinEtools.MeshLineModule.L2block-Tuple{Float64,Int64}"><code>FinEtools.MeshLineModule.L2block</code></a> — <span class="docstring-category">Method</span></header><section><div><p>L2block(Length::FFlt, nL::FInt)</p><p>Mesh of a 1-D block of L2 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshLineModule.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshLineModule.L2blockx-Tuple{Array{Float64,1}}" href="#FinEtools.MeshLineModule.L2blockx-Tuple{Array{Float64,1}}"><code>FinEtools.MeshLineModule.L2blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><p>L2blockx(xs::FFltVec)</p><p>Graded mesh of a 1-D block, L2 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshLineModule.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshLineModule.L3blockx-Tuple{Array{Float64,1}}" href="#FinEtools.MeshLineModule.L3blockx-Tuple{Array{Float64,1}}"><code>FinEtools.MeshLineModule.L3blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">L3blockx(xs::FFltVec)</code></pre><p>Graded mesh of a 1-D block, L2 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshLineModule.jl#L42-L46">source</a></section></article><h3 id="Meshing-with-triangles-1"><a class="docs-heading-anchor" href="#Meshing-with-triangles-1">Meshing with triangles</a><a class="docs-heading-anchor-permalink" href="#Meshing-with-triangles-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.Q4toT3" href="#FinEtools.MeshTriangleModule.Q4toT3"><code>FinEtools.MeshTriangleModule.Q4toT3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Q4toT3(fens::FENodeSet, fes::FESetQ4, orientation::Symbol=:default)</code></pre><p>Convert a mesh of quadrilateral Q4&#39;s to two T3 triangles  each.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshTriangleModule.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3annulus" href="#FinEtools.MeshTriangleModule.T3annulus"><code>FinEtools.MeshTriangleModule.T3annulus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">T3annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt, orientation::Symbol=:a)</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius <code>rin</code>, and  external radius <code>rex</code>, and  development angle <code>Angl</code> (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshTriangleModule.jl#L197-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3block" href="#FinEtools.MeshTriangleModule.T3block"><code>FinEtools.MeshTriangleModule.T3block</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">T3block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt, orientation::Symbol=:a)</code></pre><p>T3 Mesh of a rectangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshTriangleModule.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3blockx" href="#FinEtools.MeshTriangleModule.T3blockx"><code>FinEtools.MeshTriangleModule.T3blockx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">T3blockx(xs::FFltVec, ys::FFltVec, orientation::Symbol=:a)</code></pre><p>T3 Mesh of a rectangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshTriangleModule.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3refine-Tuple{FENodeSet,FESetT3}" href="#FinEtools.MeshTriangleModule.T3refine-Tuple{FENodeSet,FESetT3}"><code>FinEtools.MeshTriangleModule.T3refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">T3refine(fens::FENodeSet,fes::FESetT3)</code></pre><p>Refine a mesh of 3-node triangles by quadrisection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshTriangleModule.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T3toT6-Tuple{FENodeSet,FESetT3}" href="#FinEtools.MeshTriangleModule.T3toT6-Tuple{FENodeSet,FESetT3}"><code>FinEtools.MeshTriangleModule.T3toT6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">T3toT6(fens::FENodeSet, fes::FESetT3)</code></pre><p>Convert a mesh of triangle T3 (three-node) to triangle T6.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshTriangleModule.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T6annulus" href="#FinEtools.MeshTriangleModule.T6annulus"><code>FinEtools.MeshTriangleModule.T6annulus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">T6annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt, orientation::Symbol=:a)</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius <code>rin</code>, and  external radius <code>rex</code>, and  development angle <code>Angl</code> (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshTriangleModule.jl#L219-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T6block" href="#FinEtools.MeshTriangleModule.T6block"><code>FinEtools.MeshTriangleModule.T6block</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">T6block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt, orientation::Symbol=:a)</code></pre><p>Mesh of a rectangle of T6 elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshTriangleModule.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshTriangleModule.T6blockx" href="#FinEtools.MeshTriangleModule.T6blockx"><code>FinEtools.MeshTriangleModule.T6blockx</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">T6blockx(xs::FFltVec, ys::FFltVec, orientation::Symbol=:a)</code></pre><p>Graded mesh of a 2-D block of T6 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshTriangleModule.jl#L139-L143">source</a></section></article><h3 id="Meshing-with-quadrilaterals-1"><a class="docs-heading-anchor" href="#Meshing-with-quadrilaterals-1">Meshing with quadrilaterals</a><a class="docs-heading-anchor-permalink" href="#Meshing-with-quadrilaterals-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4annulus-Tuple{Float64,Float64,Int64,Int64,Float64}" href="#FinEtools.MeshQuadrilateralModule.Q4annulus-Tuple{Float64,Float64,Int64,Int64,Float64}"><code>FinEtools.MeshQuadrilateralModule.Q4annulus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q4annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt)</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius <code>rin</code>, and  external radius <code>rex</code>, and  development angle <code>Angl</code> (in radians). Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4block-Tuple{Float64,Float64,Int64,Int64}" href="#FinEtools.MeshQuadrilateralModule.Q4block-Tuple{Float64,Float64,Int64,Int64}"><code>FinEtools.MeshQuadrilateralModule.Q4block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q4block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt)</code></pre><p>Mesh of a rectangle, Q4 elements.</p><p>Divided into elements: nL, nW in the first, second (x,y).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L119-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4blockx-Tuple{Array{Float64,1},Array{Float64,1}}" href="#FinEtools.MeshQuadrilateralModule.Q4blockx-Tuple{Array{Float64,1},Array{Float64,1}}"><code>FinEtools.MeshQuadrilateralModule.Q4blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q4blockx(xs::FFltVec, ys::FFltVec)</code></pre><p>Graded mesh  of a rectangle, Q4 finite elements.</p><pre><code class="language-none">Mesh of a 2-D block, Q4 finite elements. The nodes are located at the
Cartesian product of the two intervals on the input.  This allows for
construction of graded meshes.

xs,ys - Locations of the individual planes of nodes.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L130-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4circlen-Tuple{Float64,Any}" href="#FinEtools.MeshQuadrilateralModule.Q4circlen-Tuple{Float64,Any}"><code>FinEtools.MeshQuadrilateralModule.Q4circlen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q4circlen(radius::FFlt, nperradius)</code></pre><p>Mesh of a quarter circle with a given number of elements per radius.</p><p>The parameter <code>nperradius</code> should be an even  number; if that isn&#39;t so is adjusted to by adding one. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L402-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4elliphole-Tuple{Float64,Float64,Float64,Float64,Int64,Int64,Int64}" href="#FinEtools.MeshQuadrilateralModule.Q4elliphole-Tuple{Float64,Float64,Float64,Float64,Int64,Int64,Int64}"><code>FinEtools.MeshQuadrilateralModule.Q4elliphole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q4elliphole(xradius::FFlt, yradius::FFlt, L::FFlt, H::FFlt,
  nL::FInt, nH::FInt, nW::FInt)</code></pre><p>Mesh of one quarter of a rectangular plate with an elliptical hole.</p><pre><code class="language-none">xradius,yradius = radius of the ellipse,
L,H= and dimensions of the plate,
nL,nH= numbers of edges along the side of the plate; this also happens
  to be the number of edges along the circumference of the elliptical
  hole
nW= number of edges along the remaining straight edge (from the hole
  in the direction of the length),</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L75-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4quadrilateral-Tuple{Array{Float64,2},Int64,Int64}" href="#FinEtools.MeshQuadrilateralModule.Q4quadrilateral-Tuple{Array{Float64,2},Int64,Int64}"><code>FinEtools.MeshQuadrilateralModule.Q4quadrilateral</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q4quadrilateral(xyz::FFltMat, nL::FInt, nW::FInt)</code></pre><p>Mesh of a general quadrilateral given by the location of the vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4refine-Tuple{FENodeSet,FESetQ4}" href="#FinEtools.MeshQuadrilateralModule.Q4refine-Tuple{FENodeSet,FESetQ4}"><code>FinEtools.MeshQuadrilateralModule.Q4refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q4refine(fens::FENodeSet, fes::FESetQ4)</code></pre><p>Refine a mesh of quadrilaterals by bisection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4spheren-Tuple{Float64,Any}" href="#FinEtools.MeshQuadrilateralModule.Q4spheren-Tuple{Float64,Any}"><code>FinEtools.MeshQuadrilateralModule.Q4spheren</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bar(x[, y])</code></pre><p>Compute</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L373-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q4toQ8-Tuple{FENodeSet,FESetQ4}" href="#FinEtools.MeshQuadrilateralModule.Q4toQ8-Tuple{FENodeSet,FESetQ4}"><code>FinEtools.MeshQuadrilateralModule.Q4toQ8</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q4toQ8(fens::FENodeSet, fes::FESetQ4)</code></pre><p>Convert a mesh of quadrilateral Q4 to quadrilateral Q8.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L201-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q8annulus-Tuple{Float64,Float64,Int64,Int64,Float64}" href="#FinEtools.MeshQuadrilateralModule.Q8annulus-Tuple{Float64,Float64,Int64,Int64,Float64}"><code>FinEtools.MeshQuadrilateralModule.Q8annulus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q8annulus(rin::FFlt, rex::FFlt, nr::FInt, nc::FInt, Angl::FFlt)</code></pre><p>Mesh of an annulus segment.</p><p>Mesh of an annulus segment, centered at the origin, with internal radius rin, and  external radius rex, and  development angle Angl. Divided into elements: nr, nc in the radial and circumferential direction respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L327-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q8block-Tuple{Float64,Float64,Int64,Int64}" href="#FinEtools.MeshQuadrilateralModule.Q8block-Tuple{Float64,Float64,Int64,Int64}"><code>FinEtools.MeshQuadrilateralModule.Q8block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q8block(Length::FFlt, Width::FFlt, nL::FInt, nW::FInt)</code></pre><p>Mesh of a rectangle of Q8 elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshQuadrilateralModule.Q8blockx-Tuple{Array{Float64,1},Array{Float64,1}}" href="#FinEtools.MeshQuadrilateralModule.Q8blockx-Tuple{Array{Float64,1},Array{Float64,1}}"><code>FinEtools.MeshQuadrilateralModule.Q8blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Q8blockx(xs::FFltVec, ys::FFltVec)</code></pre><p>Graded mesh of a 2-D block of Q8 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshQuadrilateralModule.jl#L254-L258">source</a></section></article><h3 id="Meshing-with-tetrahedra-1"><a class="docs-heading-anchor" href="#Meshing-with-tetrahedra-1">Meshing with tetrahedra</a><a class="docs-heading-anchor-permalink" href="#Meshing-with-tetrahedra-1" title="Permalink"></a></h3><pre><code class="language-">Modules = [FinEtools, FinEtools.MeshTetrahedronModule, FinEtools.VoxelBoxModule, FinEtools.VoxelTetMeshingModule]
Private = true
Order = [:function]</code></pre><h3 id="Meshing-with-hexahedra-1"><a class="docs-heading-anchor" href="#Meshing-with-hexahedra-1">Meshing with hexahedra</a><a class="docs-heading-anchor-permalink" href="#Meshing-with-hexahedra-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H20block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}" href="#FinEtools.MeshHexahedronModule.H20block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}"><code>FinEtools.MeshHexahedronModule.H20block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H20block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)</code></pre><p>Create mesh of a 3-D block of H20 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L476-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H20blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#FinEtools.MeshHexahedronModule.H20blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>FinEtools.MeshHexahedronModule.H20blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H20blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)</code></pre><p>Graded mesh of a 3-D block of H20 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L486-L490">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H27block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}" href="#FinEtools.MeshHexahedronModule.H27block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}"><code>FinEtools.MeshHexahedronModule.H27block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H27block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)</code></pre><p>Create mesh of a 3-D block of H27 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H27blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#FinEtools.MeshHexahedronModule.H27blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>FinEtools.MeshHexahedronModule.H27blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H27blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)</code></pre><p>Graded mesh of a 3-D block of H27 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L330-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}" href="#FinEtools.MeshHexahedronModule.H8block-Tuple{Float64,Float64,Float64,Int64,Int64,Int64}"><code>FinEtools.MeshHexahedronModule.H8block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8block(Length::FFlt, Width::FFlt, Height::FFlt, nL::FInt, nW::FInt, nH::FInt)</code></pre><p>Make  a mesh  of a 3D block consisting of  eight node hexahedra.</p><p>Length, Width, Height= dimensions of the mesh in Cartesian coordinate axes, smallest coordinate in all three directions is  0 (origin) nL, nW, nH=number of elements in the three directions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L18-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#FinEtools.MeshHexahedronModule.H8blockx-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>FinEtools.MeshHexahedronModule.H8blockx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8blockx(xs::FFltVec, ys::FFltVec, zs::FFltVec)</code></pre><p>Graded mesh of a 3-D block of H8 finite elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8cylindern-Tuple{Float64,Float64,Any,Any}" href="#FinEtools.MeshHexahedronModule.H8cylindern-Tuple{Float64,Float64,Any,Any}"><code>FinEtools.MeshHexahedronModule.H8cylindern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8cylindern(Radius::FFlt, Length::FFlt, nperradius, nL)</code></pre><p>H8 mesh of a solid  cylinder with given number of edges per radius (<code>nperradius</code>) and per length (<code>nL</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L702-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8elliphole-Tuple{Float64,Float64,Float64,Float64,Float64,Int64,Int64,Int64,Int64}" href="#FinEtools.MeshHexahedronModule.H8elliphole-Tuple{Float64,Float64,Float64,Float64,Float64,Int64,Int64,Int64,Int64}"><code>FinEtools.MeshHexahedronModule.H8elliphole</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8elliphole(xradius::FFlt, yradius::FFlt, L::FFlt, H::FFlt, T::FFlt,
    nL::FInt, nH::FInt, nW::FInt, nT::FInt)</code></pre><p>Mesh of one quarter of a rectangular plate with an elliptical hole.</p><p><code>xradius</code>,<code>yradius</code> = radii of the ellipse, <code>L</code>,<code>H</code> = dimensions of the plate, <code>T</code> = thickness of the plate <code>nL</code>,<code>nH</code>= numbers of edges along the side of the plate; this is also   the number of edges along the circumference of the elliptical hole <code>nW</code> = number of edges along the remaining straight edge (from the hole   in the radial direction),</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L679-L692">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8extrudeQ4-Union{Tuple{F}, Tuple{FENodeSet,FESetQ4,Int64,F}} where F&lt;:Function" href="#FinEtools.MeshHexahedronModule.H8extrudeQ4-Union{Tuple{F}, Tuple{FENodeSet,FESetQ4,Int64,F}} where F&lt;:Function"><code>FinEtools.MeshHexahedronModule.H8extrudeQ4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8extrudeQ4(fens::FENodeSet,  fes::FESetQ4, nLayers::FInt, extrusionh::Function)</code></pre><p>Extrude a mesh of quadrilaterals into a mesh of hexahedra (H8).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L369-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8hexahedron-Tuple{Array{Float64,2},Int64,Int64,Int64}" href="#FinEtools.MeshHexahedronModule.H8hexahedron-Tuple{Array{Float64,2},Int64,Int64,Int64}"><code>FinEtools.MeshHexahedronModule.H8hexahedron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8hexahedron(xyz::FFltMat, nL::FInt, nW::FInt, nH::FInt; blockfun=nothing)</code></pre><p>Mesh of a general hexahedron given by the location of the vertices.</p><p><code>xyz</code> = One vertex location per row; Either two rows (for a rectangular      block given by the its corners),  or eight rows (general hexahedron). <code>nL</code>,  <code>nW</code>,  <code>nH</code> = number of elements in each direction <code>blockfun</code> = Optional argument: function of the block-generating mesh function      (having the signature of the function <code>H8block()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L274-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8layeredplatex-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1}}" href="#FinEtools.MeshHexahedronModule.H8layeredplatex-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Int64,1}}"><code>FinEtools.MeshHexahedronModule.H8layeredplatex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8layeredplatex(xs::FFltVec, ys::FFltVec, ts::FFltVec, nts::FIntVec)</code></pre><p>H8 mesh for a layered block (composite plate) with specified in plane coordinates.</p><p>xs,ys =Locations of the individual planes of nodes. ts= Array of layer thicknesses, nts= array of numbers of elements per layer</p><p>The finite elements of each layer are labeled with the layer number, starting from 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L649-L660">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8refine-Tuple{FENodeSet,FESetH8}" href="#FinEtools.MeshHexahedronModule.H8refine-Tuple{FENodeSet,FESetH8}"><code>FinEtools.MeshHexahedronModule.H8refine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8refine(fens::FENodeSet,  fes::FESetH8)</code></pre><p>Refine a mesh of H8 hexahedrals by octasection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8sphere-Tuple{Float64,Int64}" href="#FinEtools.MeshHexahedronModule.H8sphere-Tuple{Float64,Int64}"><code>FinEtools.MeshHexahedronModule.H8sphere</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8sphere(radius::FFlt, nrefine::FInt)

Create a mesh of 1/8 of the sphere of &quot;radius&quot;. The  mesh will consist of
four hexahedral elements if &quot;nrefine==0&quot;,  or more if &quot;nrefine&gt;0&quot;.
&quot;nrefine&quot; is the number of bisections applied  to refine the mesh.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8spheren-Tuple{Float64,Int64}" href="#FinEtools.MeshHexahedronModule.H8spheren-Tuple{Float64,Int64}"><code>FinEtools.MeshHexahedronModule.H8spheren</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8spheren(radius::FFlt, nperradius::FInt)</code></pre><p>Create a solid mesh of 1/8 of sphere.</p><p>Create a solid mesh of 1/8 of the sphere of &quot;radius&quot;,  with nperradius elements per radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L385-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8toH20-Tuple{FENodeSet,FESetH8}" href="#FinEtools.MeshHexahedronModule.H8toH20-Tuple{FENodeSet,FESetH8}"><code>FinEtools.MeshHexahedronModule.H8toH20</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8toH20(fens::FENodeSet,  fes::FESetH8)</code></pre><p>Convert a mesh of hexahedra H8 to hexahedra H20.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L496-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8toH27-Tuple{FENodeSet,FESetH8}" href="#FinEtools.MeshHexahedronModule.H8toH27-Tuple{FENodeSet,FESetH8}"><code>FinEtools.MeshHexahedronModule.H8toH27</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8toH27(fens::FENodeSet,  fes::FESetH8)

Convert a mesh of hexahedra H8 to hexahedra H27.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.H8voximg-Union{Tuple{DataT}, Tuple{Array{DataT,3},Array{Float64,1},Array{DataT,1}}} where DataT&lt;:Number" href="#FinEtools.MeshHexahedronModule.H8voximg-Union{Tuple{DataT}, Tuple{Array{DataT,3},Array{Float64,1},Array{DataT,1}}} where DataT&lt;:Number"><code>FinEtools.MeshHexahedronModule.H8voximg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">H8voximg(img::Array{DataT, 3}, voxdims::FFltVec,
    voxval::Array{DataT, 1}) where {DataT&lt;:Number}</code></pre><p>Generate a hexahedral mesh  from three-dimensional image.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L628-L633">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshHexahedronModule.T4toH8-Tuple{FENodeSet,FESetT4}" href="#FinEtools.MeshHexahedronModule.T4toH8-Tuple{FENodeSet,FESetT4}"><code>FinEtools.MeshHexahedronModule.T4toH8</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">T4toH8(fens::FENodeSet, fes::FESetT4)</code></pre><p>Convert a tetrahedral four-node mesh into eight-node hexahedra.</p><p>Each vertex is given one hexahedron. The scheme generates 15 nodes per tetrahedron when creating the hexahedra, one for each edge, one for each face, and one for the interior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshHexahedronModule.jl#L727-L735">source</a></section></article><h3 id="Mesh-selection-1"><a class="docs-heading-anchor" href="#Mesh-selection-1">Mesh selection</a><a class="docs-heading-anchor-permalink" href="#Mesh-selection-1" title="Permalink"></a></h3><p>See above as &quot;Selecting nodes and elements&quot;.</p><h3 id="Mesh-modification-1"><a class="docs-heading-anchor" href="#Mesh-modification-1">Mesh modification</a><a class="docs-heading-anchor-permalink" href="#Mesh-modification-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule._coldeg-Tuple{SparseArrays.SparseMatrixCSC,Int64}" href="#FinEtools.MeshModificationModule._coldeg-Tuple{SparseArrays.SparseMatrixCSC,Int64}"><code>FinEtools.MeshModificationModule._coldeg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_coldeg(A::SparseMatrixCSC, j::Int)</code></pre><p>This function has been modified from source of (https://github.com/rleegates/CuthillMcKee.jl/blob/master/src/CuthillMcKee.jl)</p><p><code>A</code> is assumed to be symmetric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L1023-L1030">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.adjgraph-Tuple{Any,Any}" href="#FinEtools.MeshModificationModule.adjgraph-Tuple{Any,Any}"><code>FinEtools.MeshModificationModule.adjgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjgraph(conn, nfens)</code></pre><p>Compute the adjacency graph from the array of connectivities of the elements in the mesh.</p><p><strong>Examples</strong></p><pre><code class="language-none">conn = [9 1 8 4;
       1 3 2 8;
       8 2 7 5;
       2 6 7 7];
nfens = 9;
adjgraph(conn, nfens)
</code></pre><p>should produce <code>9-element Array{Array{Int64,1},1}:  [9, 8, 4, 3, 2]  [1, 3, 8, 7, 5, 6]  [1, 2, 8]  [9, 1, 8]  [8, 2, 7]  [2, 7]  [8, 2, 5, 6]  [9, 1, 4, 3, 2, 7, 5]  [1, 8, 4]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L972-L1002">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.adjgraph-Tuple{SparseArrays.SparseMatrixCSC}" href="#FinEtools.MeshModificationModule.adjgraph-Tuple{SparseArrays.SparseMatrixCSC}"><code>FinEtools.MeshModificationModule.adjgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adjgraph(A)</code></pre><p>Compute the adjacency graph from a sparse matrix. This function has been modified from source of (https://github.com/rleegates/CuthillMcKee.jl/blob/master/src/CuthillMcKee.jl)</p><p><code>A</code> is assumed to be symmetric.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L1036-L1044">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.compactnodes-Tuple{FENodeSet,BitArray{1}}" href="#FinEtools.MeshModificationModule.compactnodes-Tuple{FENodeSet,BitArray{1}}"><code>FinEtools.MeshModificationModule.compactnodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compactnodes(fens::FENodeSet, connected::Vector{Bool})</code></pre><p>Compact the finite element node set by deleting unconnected nodes.</p><p><code>fens</code> = array of finite element nodes <code>connected</code> = The array element <code>connected[j]</code> is either 0 (when <code>j</code> is an   unconnected node), or a positive number (when node <code>j</code> is connected to   other nodes by at least one finite element)</p><p><strong>Output</strong></p><p><code>fens</code> = new set of finite element nodes <code>new_numbering</code>= array which tells where in the new <code>fens</code> array the      connected nodes are (or 0 when the node was unconnected). For instance,      node 5 was connected, and in the new array it is the third node: then      <code>new_numbering[5]</code> is 3.</p><p><strong>Examples</strong></p><p>Let us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.</p><pre><code class="language-none">connected = findunconnnodes(fens, fes);
fens, new_numbering = compactnodes(fens, connected);
fes = renumberconn!(fes, new_numbering);</code></pre><p>Finally, check that the mesh is valid:</p><pre><code class="language-none">validate_mesh(fens, fes);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L266-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.fusenodes-Tuple{FENodeSet,FENodeSet,Float64}" href="#FinEtools.MeshModificationModule.fusenodes-Tuple{FENodeSet,FENodeSet,Float64}"><code>FinEtools.MeshModificationModule.fusenodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fusenodes(fens1::FENodeSet, fens2::FENodeSet, tolerance:: FFlt)</code></pre><p>Fuse together nodes from two node sets.</p><p>Fuse two node sets. If necessary, by gluing together nodes located within tolerance of each other. The two node sets, <code>fens1</code> and <code>fens2</code>,  are fused together by merging the nodes that fall within a box of size <code>tolerance</code>. The merged node set, <code>fens</code>, and the new  indexes of the nodes in the set <code>fens1</code> are returned.</p><p>The set <code>fens2</code> will be included unchanged, in the same order, in the node set <code>fens</code>. The indexes of the node set <code>fens1</code> will have changed.</p><p><strong>Example</strong></p><p>After the call to this function we have <code>k=new_indexes_of_fens1_nodes[j]</code> is the node in the node set <code>fens</code> which used to be node <code>j</code> in node set <code>fens1</code>. The finite element set connectivity that used to refer to <code>fens1</code> needs to be updated to refer to the same nodes in  the set <code>fens</code> as      <code>updateconn!(fes, new_indexes_of_fens1_nodes);</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L161-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.interior2boundary-Tuple{Array{Int64,2},Array{Int64,2}}" href="#FinEtools.MeshModificationModule.interior2boundary-Tuple{Array{Int64,2},Array{Int64,2}}"><code>FinEtools.MeshModificationModule.interior2boundary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interior2boundary(interiorconn::Array{Int, 2}, extractb::Array{Int, 2})</code></pre><p>Extract the boundary connectivity from the connectivity of the interior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergemeshes-Union{Tuple{T2}, Tuple{T1}, Tuple{FENodeSet,T1,FENodeSet,T2,Float64}} where T2&lt;:AbstractFESet where T1&lt;:AbstractFESet" href="#FinEtools.MeshModificationModule.mergemeshes-Union{Tuple{T2}, Tuple{T1}, Tuple{FENodeSet,T1,FENodeSet,T2,Float64}} where T2&lt;:AbstractFESet where T1&lt;:AbstractFESet"><code>FinEtools.MeshModificationModule.mergemeshes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mergemeshes(fens1::FENodeSet, fes1::T1,
  fens2::FENodeSet, fes2::T2, tolerance::FFlt) where {T1&lt;:AbstractFESet,T2&lt;:AbstractFESet}</code></pre><p>Merge together two meshes.</p><p>Merge two meshes together by gluing together nodes within tolerance. The two meshes, <code>fens1</code>, <code>fes1</code>, and <code>fens2</code>, <code>fes2</code>, are glued together by merging the nodes that fall within a box of size <code>tolerance</code>. If <code>tolerance</code> is set to zero, no merging of nodes is performed; the two meshes are simply concatenated together.</p><p>The merged node set, <code>fens</code>, and the two finite element sets with renumbered  connectivities are returned.</p><p>Important notes: On entry into this function the connectivity of <code>fes1</code> point into <code>fens1</code> and the connectivity of <code>fes2</code> point into <code>fens2</code>. After this function returns the connectivity of both <code>fes1</code> and <code>fes2</code> point into <code>fens</code>. The order of the nodes of the node set <code>fens1</code> in the resulting set <code>fens</code> will have changed, whereas the order of the nodes of the node set <code>fens2</code> is are guaranteed to be the same. Therefore, the connectivity of <code>fes2</code> will in fact remain the same.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L314-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergenmeshes-Tuple{Array{Tuple{FENodeSet,AbstractFESet},N} where N,Float64}" href="#FinEtools.MeshModificationModule.mergenmeshes-Tuple{Array{Tuple{FENodeSet,AbstractFESet},N} where N,Float64}"><code>FinEtools.MeshModificationModule.mergenmeshes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mergenmeshes(meshes::Array{Tuple{FENodeSet, FESet}}, tolerance::FFlt)</code></pre><p>Merge several meshes together.</p><p>The meshes are glued together by merging the nodes that fall within a box of size <code>tolerance</code>. If <code>tolerance</code> is set to zero, no merging of nodes is performed; the nodes from the meshes are simply concatenated together.</p><p><strong>Output</strong></p><p>The merged node set, <code>fens</code>, and an array of finite element sets with renumbered  connectivities are returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L350-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergenodes-Tuple{FENodeSet,AbstractFESet,Float64,Array{Int64,1}}" href="#FinEtools.MeshModificationModule.mergenodes-Tuple{FENodeSet,AbstractFESet,Float64,Array{Int64,1}}"><code>FinEtools.MeshModificationModule.mergenodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mergenodes(fens::FENodeSet, fes::AbstractFESet, tolerance::FFlt, candidates::FIntVec)</code></pre><p>Merge together  nodes of a single node set.</p><p>Similar to <code>mergenodes(fens::FENodeSet, fes::AbstractFESet, tolerance::FFlt)</code>, but only the candidate nodes are considered for merging. This can potentially speed up the operation by orders of magnitude.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L442-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mergenodes-Tuple{FENodeSet,AbstractFESet,Float64}" href="#FinEtools.MeshModificationModule.mergenodes-Tuple{FENodeSet,AbstractFESet,Float64}"><code>FinEtools.MeshModificationModule.mergenodes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mergenodes(fens::FENodeSet, fes::AbstractFESet, tolerance::FFlt)</code></pre><p>Merge together  nodes of a single node set.</p><p>Merge by gluing together nodes from a single node set located within tolerance of each other. The nodes are glued together by merging the nodes that fall within a box of size <code>tolerance</code>. The merged node set, <code>fens</code>, and the finite element set, <code>fes</code>, with renumbered  connectivities are returned.</p><p>Warning: This tends to be an expensive operation!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L382-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.meshboundary-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet" href="#FinEtools.MeshModificationModule.meshboundary-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractFESet"><code>FinEtools.MeshModificationModule.meshboundary</code></a> — <span class="docstring-category">Method</span></header><section><div><p>meshboundary(fes::T) where {T&lt;:AbstractFESet}</p><p>Extract the boundary finite elements from a mesh.</p><p>Extract the finite elements of manifold dimension (n-1) from the supplied finite element set of manifold dimension (n).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.meshsmoothing-Union{Tuple{T}, Tuple{FENodeSet,T}} where T&lt;:AbstractFESet" href="#FinEtools.MeshModificationModule.meshsmoothing-Union{Tuple{T}, Tuple{FENodeSet,T}} where T&lt;:AbstractFESet"><code>FinEtools.MeshModificationModule.meshsmoothing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meshsmoothing(fens::FENodeSet, fes::T; options...) where {T&lt;:AbstractFESet}</code></pre><p>General smoothing of meshes.</p><p><strong>Keyword options</strong></p><p><code>method</code> = :taubin (default) or :laplace <code>fixedv</code> = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) <code>npass</code> = number of passes (default 2)</p><p><strong>Return</strong></p><p>The modified  node set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L572-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.mirrormesh-Union{Tuple{T}, Tuple{FENodeSet,T,Array{Float64,1},Array{Float64,1}}} where T&lt;:AbstractFESet" href="#FinEtools.MeshModificationModule.mirrormesh-Union{Tuple{T}, Tuple{FENodeSet,T,Array{Float64,1},Array{Float64,1}}} where T&lt;:AbstractFESet"><code>FinEtools.MeshModificationModule.mirrormesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mirrormesh(fens::FENodeSet, fes::T, Normal::FFltVec,
  Point::FFltVec; kwargs...) where {T&lt;:AbstractFESet}</code></pre><p>Mirror a mesh in a plane given by its normal and one point.</p><p><strong>Keyword arguments</strong></p><ul><li><code>renumb</code> = node renumbering function for the mirrored element</li></ul><p>Warning: The code to relies on the numbering of the finite elements: to reverse the orientation of the mirrored finite elements, the connectivity is listed in reverse order.   If the mirrored finite elements do not follow this rule (for instance hexahedra or quadrilaterals), their areas/volumes will come out negative. In such a case the renumbering function of the connectivity needs to be supplied.</p><p>For instance: H8 elements require the renumbering function to be supplied as</p><pre><code class="language-none">renumb = (c) -&gt; c[[1, 4, 3, 2, 5, 8, 7, 6]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L665-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.nodedegrees-Tuple{Array{Array{Int64,1},1}}" href="#FinEtools.MeshModificationModule.nodedegrees-Tuple{Array{Array{Int64,1},1}}"><code>FinEtools.MeshModificationModule.nodedegrees</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodedegrees(adjgr::Vector{Vector{Int}})</code></pre><p>Compute the degrees of the nodes in the adjacency graph.</p><p>conn = [9 1 8 4;        1 3 2 8;        8 2 7 5;        2 6 7 7]; nfens = 9; adjgr = adjgraph(conn, nfens) nodedegrees(adjgr)</p><p>julia&gt; degrees = node_degrees(adjgr) 9-element Array{Int64,1}:  5  6  3  3  3  2  4  7  3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L1069-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.nodepartitioning" href="#FinEtools.MeshModificationModule.nodepartitioning"><code>FinEtools.MeshModificationModule.nodepartitioning</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nodepartitioning(fens::FENodeSet, nincluded::Vector{Bool}, npartitions)</code></pre><p>Compute the inertial-cut partitioning of the nodes.</p><p><code>nincluded</code> = Boolean array: is the node to be included in the partitioning or     not? <code>npartitions</code> = number of partitions, but note that the actual number of     partitions is going to be a power of two.</p><p>The partitioning can be visualized for instance as:</p><pre><code class="language-julia">partitioning = nodepartitioning(fens, npartitions)
partitionnumbers = unique(partitioning)
for gp = partitionnumbers
  groupnodes = findall(k -&gt; k == gp, partitioning)
  File =  &quot;partition-nodes-Dollar(gp).vtk&quot;
  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))
end
File =  &quot;partition-mesh.vtk&quot;
vtkexportmesh(File, fens, fes)
@async run(`&quot;paraview.exe&quot; DollarFile`)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L857-L880">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.nodepartitioning" href="#FinEtools.MeshModificationModule.nodepartitioning"><code>FinEtools.MeshModificationModule.nodepartitioning</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nodepartitioning(fens::FENodeSet, npartitions)</code></pre><p>Compute the inertial-cut partitioning of the nodes.</p><p><code>npartitions</code> = number of partitions, but note that the actual number of partitions will be a power of two.</p><p>In this variant all the nodes are to be included in the partitioning.</p><p>The partitioning can be visualized for instance as:</p><pre><code class="language-julia">partitioning = nodepartitioning(fens, npartitions)
partitionnumbers = unique(partitioning)
for gp = partitionnumbers
  groupnodes = findall(k -&gt; k == gp, partitioning)
  File =  &quot;partition-nodes-Dollar(gp).vtk&quot;
  vtkexportmesh(File, fens, FESetP1(reshape(groupnodes, length(groupnodes), 1)))
end
File =  &quot;partition-mesh.vtk&quot;
vtkexportmesh(File, fens, fes)
@async run(`&quot;paraview.exe&quot; DollarFile`)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L892-L915">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.nodepartitioning-Tuple{FENodeSet,Any,Array{Int64,1}}" href="#FinEtools.MeshModificationModule.nodepartitioning-Tuple{FENodeSet,Any,Array{Int64,1}}"><code>FinEtools.MeshModificationModule.nodepartitioning</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nodepartitioning(fens::FENodeSet, fesarr, npartitions::Vector{Int})</code></pre><p>Compute the inertial-cut partitioning of the nodes.</p><p><code>fesarr</code> = array of finite element sets that represent regions <code>npartitions</code> = array of the number of partitions in each region. However note that the actual number of partitions will be a power of two.</p><p>The partitioning itself is carried out by <code>nodepartitioning()</code> with a list of nodes to be included in the partitioning. For each region I the nodes included in the partitioning are those connected to the elements of that region, but not to elements that belong to any of the previous regions, 1…I-1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L928-L942">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.renumberconn!-Tuple{AbstractFESet,Array{Int64,1}}" href="#FinEtools.MeshModificationModule.renumberconn!-Tuple{AbstractFESet,Array{Int64,1}}"><code>FinEtools.MeshModificationModule.renumberconn!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">renumberconn!(fes::AbstractFESet, new_numbering::FIntVec)</code></pre><p>Renumber the nodes in the connectivity of the finite elements based on a new numbering for the nodes.</p><p><code>fes</code> =finite element set <code>new_numbering</code> = new serial numbers for the nodes.  The connectivity           should be changed as <code>conn[j]</code> –&gt; <code>new_numbering[conn[j]]</code></p><p>Let us say there are nodes not connected to any finite element that you would like to remove from the mesh: here is how that would be accomplished.</p><pre><code class="language-none">connected = findunconnnodes(fens, fes);
fens, new_numbering = compactfens(fens, connected);
fes = renumberconn!(fes, new_numbering);</code></pre><p>Finally, check that the mesh is valid:</p><pre><code class="language-julia">validate_mesh(fens, fes);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L502-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.revcm-Tuple{Array{Array{Int64,1},1},Array{Int64,1}}" href="#FinEtools.MeshModificationModule.revcm-Tuple{Array{Array{Int64,1},1},Array{Int64,1}}"><code>FinEtools.MeshModificationModule.revcm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">revcm(adjgr::Vector{Vector{Int}}, degrees::Vector{Int})</code></pre><p>Reverse Cuthill-McKee node-renumbering algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L1118-L1122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.vertexneighbors-Tuple{Array{Int64,2},Int64}" href="#FinEtools.MeshModificationModule.vertexneighbors-Tuple{Array{Int64,2},Int64}"><code>FinEtools.MeshModificationModule.vertexneighbors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vertexneighbors(conn::FIntMat, nvertices::FInt)</code></pre><p>Find the node neighbors in the mesh.</p><p>Return an array of integer vectors, element I holds an array of numbers of nodes which are connected to node I (including node I).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L641-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshModificationModule.vsmoothing-Tuple{Array{Float64,2},Array{Int64,2}}" href="#FinEtools.MeshModificationModule.vsmoothing-Tuple{Array{Float64,2},Array{Int64,2}}"><code>FinEtools.MeshModificationModule.vsmoothing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vsmoothing(v::FFltMat, t::FIntMat; options...)</code></pre><p>Internal routine for mesh smoothing.</p><p>Keyword options: <code>method</code> = :taubin (default) or :laplace <code>fixedv</code> = Boolean array, one entry per vertex: is the vertex immovable (true)     or movable  (false) <code>npass</code> = number of passes (default 2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshModificationModule.jl#L533-L543">source</a></section></article><h3 id="Meshing-utilities-1"><a class="docs-heading-anchor" href="#Meshing-utilities-1">Meshing utilities</a><a class="docs-heading-anchor-permalink" href="#Meshing-utilities-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.addhyperface!-Tuple{Any,Any,Any}" href="#FinEtools.MeshUtilModule.addhyperface!-Tuple{Any,Any,Any}"><code>FinEtools.MeshUtilModule.addhyperface!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addhyperface!(container,hyperface,newn)</code></pre><p>Add a hyper face to the container.</p><p>The new node is stored in hyper face data in the container and can be retrieved later.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshUtilModule.jl#L32-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.findhyperface!-Tuple{Any,Any}" href="#FinEtools.MeshUtilModule.findhyperface!-Tuple{Any,Any}"><code>FinEtools.MeshUtilModule.findhyperface!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findhyperface!(container,hyperface)</code></pre><p>Find a hyper face in the container.</p><p>If the container holds the indicated hyper face, it is returned together with the stored new node number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshUtilModule.jl#L57-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.gradedspace-Union{Tuple{T}, Tuple{T,T,Int64}, Tuple{T,T,Int64,Any}} where T&lt;:Number" href="#FinEtools.MeshUtilModule.gradedspace-Union{Tuple{T}, Tuple{T,T,Int64}, Tuple{T,T,Int64,Any}} where T&lt;:Number"><code>FinEtools.MeshUtilModule.gradedspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradedspace(start::T, stop::T, N::Int)  where {T&lt;:Number}</code></pre><p>Generate quadratic space.</p><p>Generate a quadratic sequence of <code>N</code> numbers between <code>start</code> and <code>stop</code>. This sequence corresponds to separation of adjacent numbers that increases linearly from start to finish.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; gradedspace(2.0, 3.0, 5)
5-element Array{Float64,1}:
 2.0
 2.0625
 2.25
 2.5625
 3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshUtilModule.jl#L111-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.linearspace-Union{Tuple{T}, Tuple{T,T,Int64}} where T&lt;:Number" href="#FinEtools.MeshUtilModule.linearspace-Union{Tuple{T}, Tuple{T,T,Int64}} where T&lt;:Number"><code>FinEtools.MeshUtilModule.linearspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">linearspace(start::T, stop::T, N::Int)  where {T&lt;:Number}</code></pre><p>Generate linear space.</p><p>Generate a linear sequence of <code>N</code> numbers between  <code>start</code> and <code>stop</code> (i. e. sequence  of number with uniform intervals inbetween).</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; linearspace(2.0, 3.0, 5)
2.0:0.25:3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshUtilModule.jl#L93-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshUtilModule.makecontainer-Tuple{}" href="#FinEtools.MeshUtilModule.makecontainer-Tuple{}"><code>FinEtools.MeshUtilModule.makecontainer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makecontainer()</code></pre><p>Make hyper face container.</p><p>This is a dictionary of hyper faces, indexed with an anchor node. The anchor node is the smallest node number within the connectivity of the hyper face.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshUtilModule.jl#L22-L29">source</a></section></article><h3 id="Mesh-import-1"><a class="docs-heading-anchor" href="#Mesh-import-1">Mesh import</a><a class="docs-heading-anchor-permalink" href="#Mesh-import-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshImportModule.import_ABAQUS-Tuple{Any}" href="#FinEtools.MeshImportModule.import_ABAQUS-Tuple{Any}"><code>FinEtools.MeshImportModule.import_ABAQUS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">import_ABAQUS(filename)</code></pre><p>Import tetrahedral (4- and 10-node) or hexahedral (8- and 20-node) Abaqus mesh (.inp file).</p><p>Limitations:</p><ol><li>Only the <code>*NODE</code> and <code>*ELEMENT</code>  sections are read</li><li>Only 4-node and 10-node tetrahedra, 8-node or 20-node  hexahedra, 3-node triangles  are handled.</li></ol><p><strong>Output</strong></p><p>Data dictionary, with keys </p><ul><li>&quot;<code>fens</code>&quot; (finite element nodes), </li><li>&quot;<code>fesets</code>&quot; (array of finite element sets).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshImportModule.jl#L177-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshImportModule.import_NASTRAN-Tuple{Any}" href="#FinEtools.MeshImportModule.import_NASTRAN-Tuple{Any}"><code>FinEtools.MeshImportModule.import_NASTRAN</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">import_NASTRAN(filename)</code></pre><p>Import tetrahedral (4- and 10-node) NASTRAN mesh (.nas file).</p><p>Limitations:</p><ol><li>only the GRID and CTETRA  sections are read.</li><li>Only 4-node and 10-node tetrahedra  are handled.</li><li>The file should be free-form (data separated by commas). </li></ol><p>Some fixed-format files can also be processed (large-field, but not small-field).</p><p><strong>Output</strong></p><p>Data dictionary, with keys </p><ul><li>&quot;<code>fens</code>&quot; (finite element nodes), </li><li>&quot;<code>fesets</code>&quot; (array of finite element sets).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshImportModule.jl#L41-L56">source</a></section></article><h3 id="Mesh-export-1"><a class="docs-heading-anchor" href="#Mesh-export-1">Mesh export</a><a class="docs-heading-anchor-permalink" href="#Mesh-export-1" title="Permalink"></a></h3><h4 id="VTK-1"><a class="docs-heading-anchor" href="#VTK-1">VTK</a><a class="docs-heading-anchor-permalink" href="#VTK-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTK.vtkexportmesh-Tuple{String,Any,Any,Any}" href="#FinEtools.MeshExportModule.VTK.vtkexportmesh-Tuple{String,Any,Any,Any}"><code>FinEtools.MeshExportModule.VTK.vtkexportmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vtkexportmesh(theFile::String, Connectivity, Points, Cell_type;
    vectors=nothing, scalars=nothing)</code></pre><p>Export mesh to a VTK 1.0 file as an unstructured grid.</p><p><code>opts</code> = keyword argument list, where <code>scalars</code> = array of tuples, (name, data) <code>vectors</code> = array of tuples, (name, data)</p><p>For the <code>scalars</code>: If <code>data</code> is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L61-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTK.vtkexportmesh-Union{Tuple{T}, Tuple{String,FENodeSet,T}} where T&lt;:AbstractFESet" href="#FinEtools.MeshExportModule.VTK.vtkexportmesh-Union{Tuple{T}, Tuple{String,FENodeSet,T}} where T&lt;:AbstractFESet"><code>FinEtools.MeshExportModule.VTK.vtkexportmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vtkexportmesh(theFile::String, fens::FENodeSet, fes::T; opts...) where {T&lt;:AbstractFESet}</code></pre><p>Export mesh to a VTK 1.0 file as an unstructured grid.</p><p><code>opts</code> = keyword argument list, where <code>scalars</code> = array of tuples, (name, data) <code>vectors</code> = array of tuples, (name, data)</p><p>For the <code>scalars</code>: If <code>data</code> is a vector, that data is exported as a single field. On the other hand, if it is an 2d array, each column is exported  as a separate field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L42-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.VTK.vtkexportvectors-Tuple{String,Any,Any}" href="#FinEtools.MeshExportModule.VTK.vtkexportvectors-Tuple{String,Any,Any}"><code>FinEtools.MeshExportModule.VTK.vtkexportvectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vtkexportvectors(theFile::String, Points, vectors)</code></pre><p>Export vector data to a VTK 1.0 file.</p><ul><li><code>Points</code> = array of collection of coordinates (tuples or vectors), </li><li><code>vectors</code> = array of tuples, <code>(name, data)</code>, where <code>name</code> is a string, and <code>data</code> is array of collection of coordinates (tuples or vectors).</li></ul><p><strong>Example</strong></p><pre><code class="language-none">Points = [(1.0, 3.0), (0.0, -1.0)]
vectors = [(&quot;v&quot;, [(-1.0, -2.0), (1.0, 1.0)])]
vtkexportvectors(&quot;theFile.VTK&quot;, Points, vectors)</code></pre><p>will produce file with</p><pre><code class="language-none"># vtk DataFile Version 1.0
FinEtools Export
ASCII

DATASET UNSTRUCTURED_GRID
POINTS 2 double
1.0 3.0 0.0
0.0 -1.0 0.0


POINT_DATA 2
VECTORS v double
-1.0 -2.0 0.0
1.0 1.0 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L223-L255">source</a></section></article><h4 id="Abaqus-1"><a class="docs-heading-anchor" href="#Abaqus-1">Abaqus</a><a class="docs-heading-anchor-permalink" href="#Abaqus-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Base.close-Tuple{AbaqusExporter}" href="#Base.close-Tuple{AbaqusExporter}"><code>Base.close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">close(self::AbaqusExporter)</code></pre><p>Close  the stream opened by the exporter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L904-L908">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ASSEMBLY-Tuple{AbaqusExporter,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.ASSEMBLY-Tuple{AbaqusExporter,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.ASSEMBLY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ASSEMBLY(self::AbaqusExporter, NAME::AbstractString)</code></pre><p>Write out the <code>*ASSEMBLY</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L377-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter,AbstractString,Integer,Float64}" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter,AbstractString,Integer,Float64}"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,  fixed_value::FFlt)</code></pre><p>Write out the <code>*BOUNDARY</code> option.</p><p><code>NSET</code> = name of a node set, <code>is_fixed</code>= array of Boolean flags (true means fixed, or prescribed),  one row per node, <code>fixed_value</code>=array of displacements to which the corresponding displacement components is fixed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L761-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter,AbstractString,Integer}" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Tuple{AbaqusExporter,AbstractString,Integer}"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer)</code></pre><p>Write out the <code>*BOUNDARY</code> option to fix displacements at zero for a node set.</p><p>Invoke at Level: Model,  Step</p><p><code>NSET</code>= node set, <code>dof</code>=Degree of freedom, 1, 2, 3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L775-L784">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,Integer,F}} where F" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,Integer,F}} where F"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BOUNDARY(self::AbaqusExporter, NSET::AbstractString, dof::Integer,
  value::F) where {F}</code></pre><p>Write out the <code>*BOUNDARY</code> option to fix displacements at nonzero value for a node set.</p><p><code>NSET</code>= node set, <code>dof</code>=Degree of freedom, 1, 2, 3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L789-L798">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter,Any,AbstractArray{B,2},AbstractArray{F,2}}} where F where B" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter,Any,AbstractArray{B,2},AbstractArray{F,2}}} where F where B"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BOUNDARY(self::AbaqusExporter, meshornset, is_fixed::AbstractArray{B,2}, fixed_value::AbstractArray{F,2}) where {B, F}</code></pre><p>Write out the <code>*BOUNDARY</code> option.</p><p><code>meshornset</code> = name of a mesh or a node set, <code>is_fixed</code>= array of Boolean flags (true means fixed, or prescribed),  one row per node, as many columns as there are degrees of freedom per node, <code>fixed_value</code>=array of displacements to which the corresponding displacement components is fixed, as many columns as there are degrees of freedom per node</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L748-L756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter,Any,Any,AbstractArray{B,2},AbstractArray{F,2}}} where F where B" href="#FinEtools.MeshExportModule.Abaqus.BOUNDARY-Union{Tuple{F}, Tuple{B}, Tuple{AbaqusExporter,Any,Any,AbstractArray{B,2},AbstractArray{F,2}}} where F where B"><code>FinEtools.MeshExportModule.Abaqus.BOUNDARY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BOUNDARY(self::AbaqusExporter, mesh, nodes, is_fixed::AbstractArray{B,2}, fixed_value::AbstractArray{F,2}) where {B, F}</code></pre><p>Write out the <code>*BOUNDARY</code> option. </p><p>The boundary condition is applied to the nodes specified in  the array <code>nodes</code>, in the mesh (or node set) <code>meshornset</code>.</p><p><code>meshornset</code> = mesh or node set (default is empty) <code>nodes</code> = array of node numbers, the node numbers are attached to the mesh label, <code>is_fixed</code>= array of Boolean flags (true means fixed, or prescribed),  one row per node, <code>fixed_value</code>=array of displacements to which the corresponding displacement components is fixed</p><p><strong>Example</strong></p><pre><code class="language-none">BOUNDARY(AE, &quot;ASSEM1.INSTNC1&quot;, 1:4, fill(true, 4, 1), reshape([uy(fens.xyz[i, :]...) for i in 1:4], 4, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L708-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,Integer,F}} where F" href="#FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,Integer,F}} where F"><code>FinEtools.MeshExportModule.Abaqus.CLOAD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CLOAD(self::AbaqusExporter, NSET::AbstractString, dof::Integer,
  magnitude::F) where {F}</code></pre><p>Write out the <code>*CLOAD</code> option.</p><p>NSET=Node set dof= 1, 2, 3, magnitude= signed multiplier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L817-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,Integer,Integer,F}} where F" href="#FinEtools.MeshExportModule.Abaqus.CLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,Integer,Integer,F}} where F"><code>FinEtools.MeshExportModule.Abaqus.CLOAD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CLOAD(self::AbaqusExporter, nodenumber::Integer, dof::Integer,
  magnitude::F) where {F}</code></pre><p>Write out the <code>*CLOAD</code> option.</p><p>nodenumber=Number of node dof= 1, 2, 3, magnitude= signed multiplier</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L833-L842">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.COMMENT-Tuple{AbaqusExporter,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.COMMENT-Tuple{AbaqusExporter,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.COMMENT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">COMMENT(self::AbaqusExporter, Text::AbstractString)</code></pre><p>Write out the <code>**</code> comment option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L340-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.DENSITY-Tuple{AbaqusExporter,Any}" href="#FinEtools.MeshExportModule.Abaqus.DENSITY-Tuple{AbaqusExporter,Any}"><code>FinEtools.MeshExportModule.Abaqus.DENSITY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DENSITY(self::AbaqusExporter, rho)</code></pre><p>Write out the <code>*DENSITY</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L578-L582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.DLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,AbstractArray{F,1}}} where F" href="#FinEtools.MeshExportModule.Abaqus.DLOAD-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,AbstractArray{F,1}}} where F"><code>FinEtools.MeshExportModule.Abaqus.DLOAD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DLOAD(self::AbaqusExporter, ELSET::AbstractString,
  traction::AbstractVector{F}) where {F}</code></pre><p>Write out the <code>*DLOAD</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L804-L809">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter,F,F,F,F,F,F,F,F,F}} where F" href="#FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter,F,F,F,F,F,F,F,F,F}} where F"><code>FinEtools.MeshExportModule.Abaqus.ELASTIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ELASTIC(self::AbaqusExporter, E1::F, E2::F, E3::F, nu12::F, nu13::F, nu23::F,
  G12::F, G13::F, G23::F) where {F}</code></pre><p>Write out the <code>*ELASTIC,TYPE=ENGINEERING CONSTANTS</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L545-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter,F,F}} where F" href="#FinEtools.MeshExportModule.Abaqus.ELASTIC-Union{Tuple{F}, Tuple{AbaqusExporter,F,F}} where F"><code>FinEtools.MeshExportModule.Abaqus.ELASTIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ELASTIC(self::AbaqusExporter, E::F, nu::F) where {F}</code></pre><p>Write out the <code>*ELASTIC,TYPE=ISOTROPIC</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L558-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ELEMENT-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractString,Integer,AbstractArray{T,2}}} where T&lt;:Integer" href="#FinEtools.MeshExportModule.Abaqus.ELEMENT-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractString,Integer,AbstractArray{T,2}}} where T&lt;:Integer"><code>FinEtools.MeshExportModule.Abaqus.ELEMENT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ELEMENT(self::AbaqusExporter, TYPE::AbstractString, ELSET::AbstractString,
  start::Integer, conn::AbstractArray{T, 2}) where {T&lt;:Integer}</code></pre><p>Write out the <code>*ELEMENT</code> option.</p><p><code>TYPE</code>= element type code, <code>ELSET</code>= element set to which the elements belong, <code>start</code>= start the element numbering at this integer, <code>conn</code>= connectivity array for the elements, one row per element</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L431-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ELSET_ELSET-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1}}} where T&lt;:Integer" href="#FinEtools.MeshExportModule.Abaqus.ELSET_ELSET-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1}}} where T&lt;:Integer"><code>FinEtools.MeshExportModule.Abaqus.ELSET_ELSET</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ELSET_ELSET(self::AbaqusExporter, ELSET::AbstractString, n::AbstractArray{T, 1}) where {T&lt;:Integer}</code></pre><p>Write out the <code>*ELSET</code> option.</p><p><code>ELSET</code> = name of the set, <code>n</code> = array of the node numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L505-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.EL_PRINT-Tuple{AbaqusExporter,AbstractString,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.EL_PRINT-Tuple{AbaqusExporter,AbstractString,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.EL_PRINT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EL_PRINT(self::AbaqusExporter, ELSET::AbstractString, KEYS::AbstractString)</code></pre><p>Write out the <code>*EL PRINT</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L875-L879">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.END_ASSEMBLY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">END_ASSEMBLY(self::AbaqusExporter)</code></pre><p>Write out the <code>*END ASSEMBLY</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L386-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.END_INSTANCE-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.END_INSTANCE-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.END_INSTANCE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">END_INSTANCE(self::AbaqusExporter)</code></pre><p>Write out the <code>*END INSTANCE</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L404-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.END_PART-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.END_PART-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.END_PART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">END_PART(self::AbaqusExporter)</code></pre><p>Write out the <code>*END PART</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L368-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.END_STEP-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.END_STEP-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.END_STEP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">END_STEP(self::AbaqusExporter)</code></pre><p>Write out the <code>*END STEP</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L895-L899">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.ENERGY_PRINT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ENERGY_PRINT(self::AbaqusExporter)</code></pre><p>Write out the <code>*ENERGY PRINT</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L886-L890">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.EXPANSION-Union{Tuple{F}, Tuple{AbaqusExporter,F}} where F" href="#FinEtools.MeshExportModule.Abaqus.EXPANSION-Union{Tuple{F}, Tuple{AbaqusExporter,F}} where F"><code>FinEtools.MeshExportModule.Abaqus.EXPANSION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">EXPANSION(self::AbaqusExporter, CTE::F) where {F}</code></pre><p>Write out the <code>*EXPANSION</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L568-L572">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.HEADING-Tuple{AbaqusExporter,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.HEADING-Tuple{AbaqusExporter,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.HEADING</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">HEADING(self::AbaqusExporter, Text::AbstractString)</code></pre><p>Write out the <code>*HEADING</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.INSTANCE-Tuple{AbaqusExporter,AbstractString,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.INSTANCE-Tuple{AbaqusExporter,AbstractString,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.INSTANCE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">INSTANCE(self::AbaqusExporter, NAME::AbstractString, PART::AbstractString)</code></pre><p>Write out the <code>*INSTANCE</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L395-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.MATERIAL-Tuple{AbaqusExporter,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.MATERIAL-Tuple{AbaqusExporter,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.MATERIAL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MATERIAL(self::AbaqusExporter, MATERIAL::AbstractString)</code></pre><p>Write out the <code>*MATERIAL</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L536-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.NODE-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractArray{T,2}}} where T" href="#FinEtools.MeshExportModule.Abaqus.NODE-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractArray{T,2}}} where T"><code>FinEtools.MeshExportModule.Abaqus.NODE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NODE(self::AbaqusExporter, xyz::AbstractArray{T, 2}) where {T}</code></pre><p>Write out the <code>*NODE</code> option.</p><p><code>xyz</code>=array of node coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L413-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.NODE_PRINT-Tuple{AbaqusExporter,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.NODE_PRINT-Tuple{AbaqusExporter,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.NODE_PRINT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NODE_PRINT(self::AbaqusExporter, NSET::AbstractString)</code></pre><p>Write out the <code>*NODE PRINT</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L865-L869">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.NSET_NSET-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1}}} where T&lt;:Integer" href="#FinEtools.MeshExportModule.Abaqus.NSET_NSET-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1}}} where T&lt;:Integer"><code>FinEtools.MeshExportModule.Abaqus.NSET_NSET</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">NSET_NSET(self::AbaqusExporter, NSET::AbstractString,
  n::AbstractVector{T}) where {T&lt;:Integer}</code></pre><p>Write out the <code>*NSET</code> option.</p><p><code>NSET</code> = name of the set, <code>n</code> = array of the node numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L488-L496">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.ORIENTATION-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1},AbstractArray{T,1}}} where T&lt;:Real" href="#FinEtools.MeshExportModule.Abaqus.ORIENTATION-Union{Tuple{T}, Tuple{AbaqusExporter,AbstractString,AbstractArray{T,1},AbstractArray{T,1}}} where T&lt;:Real"><code>FinEtools.MeshExportModule.Abaqus.ORIENTATION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ORIENTATION(self::AbaqusExporter, ORIENTATION::AbstractString,
  a::AbstractArray{T,1}, b::AbstractArray{T,1})</code></pre><p>Write out the <code>*ORIENTATION</code> option.</p><p>Invoke at level: Part,  Part instance,  Assembly</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L521-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.PART-Tuple{AbaqusExporter,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.PART-Tuple{AbaqusExporter,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.PART</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PART(self::AbaqusExporter, NAME::AbstractString)</code></pre><p>Write out the <code>*PART</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS-Tuple{AbaqusExporter,AbstractString,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS-Tuple{AbaqusExporter,AbstractString,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.SECTION_CONTROLS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SECTION_CONTROLS(self::AbaqusExporter, NAME::AbstractString,
  OPTIONAL::AbstractString)</code></pre><p>Write out the <code>*SECTION CONTROLS</code> option.</p><p><code>OPTIONAL</code> = string, for instance                      HOURGLASS=ENHANCED</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L588-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.SOLID_SECTION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,
  ORIENTATION::AbstractString, ELSET::AbstractString,
  CONTROLS::AbstractString)</code></pre><p>Write out the <code>*SOLID SECTION</code> option.</p><p>Level: Part,  Part instance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L602-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.SOLID_SECTION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,
  ORIENTATION::AbstractString, ELSET::AbstractString)</code></pre><p>Write out the <code>*SOLID SECTION</code> option.</p><p>Level: Part,  Part instance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L620-L628">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString,F}} where F" href="#FinEtools.MeshExportModule.Abaqus.SOLID_SECTION-Union{Tuple{F}, Tuple{AbaqusExporter,AbstractString,AbstractString,AbstractString,F}} where F"><code>FinEtools.MeshExportModule.Abaqus.SOLID_SECTION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SOLID_SECTION(self::AbaqusExporter, MATERIAL::AbstractString,
  ORIENTATION::AbstractString, ELSET::AbstractString)</code></pre><p>Write out the <code>*SOLID SECTION</code> option.</p><p>Level: Part,  Part instance</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L635-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY-Tuple{AbaqusExporter,Integer}" href="#FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY-Tuple{AbaqusExporter,Integer}"><code>FinEtools.MeshExportModule.Abaqus.STEP_FREQUENCY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">STEP_FREQUENCY(self::AbaqusExporter, Nmodes::Integer)</code></pre><p>Write out the <code>*STEP,FREQUENCY</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L697-L701">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE-Tuple{AbaqusExporter,Integer}" href="#FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE-Tuple{AbaqusExporter,Integer}"><code>FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_BUCKLE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">STEP_PERTURBATION_BUCKLE(self::AbaqusExporter, neigv::Integer)</code></pre><p>Write out the <code>*STEP,PERTURBATION</code> option for linear buckling analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L686-L690">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC-Tuple{AbaqusExporter}" href="#FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC-Tuple{AbaqusExporter}"><code>FinEtools.MeshExportModule.Abaqus.STEP_PERTURBATION_STATIC</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">STEP_PERTURBATION_STATIC(self::AbaqusExporter)</code></pre><p>Write out the <code>*STEP,PERTURBATION</code> option for linear static analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L676-L680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION-Tuple{AbaqusExporter,AbstractString}" href="#FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION-Tuple{AbaqusExporter,AbstractString}"><code>FinEtools.MeshExportModule.Abaqus.SURFACE_SECTION</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SURFACE_SECTION(self::AbaqusExporter, ELSET::AbstractString)</code></pre><p>Write out the <code>*SURFACE SECTION</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L667-L671">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.Abaqus.TEMPERATURE-Union{Tuple{F}, Tuple{I}, Tuple{AbaqusExporter,AbstractString,AbstractArray{I,1},AbstractArray{F,1}}} where F where I" href="#FinEtools.MeshExportModule.Abaqus.TEMPERATURE-Union{Tuple{F}, Tuple{I}, Tuple{AbaqusExporter,AbstractString,AbstractArray{I,1},AbstractArray{F,1}}} where F where I"><code>FinEtools.MeshExportModule.Abaqus.TEMPERATURE</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">TEMPERATURE(self::AbaqusExporter, nlist::AbstractArray{I, 1},
  tlist::AbstractArray{F, 1}) where {I, F}</code></pre><p>Write out the <code>*TEMPERATURE</code> option.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L849-L854">source</a></section></article><h4 id="NASTRAN-1"><a class="docs-heading-anchor" href="#NASTRAN-1">NASTRAN</a><a class="docs-heading-anchor-permalink" href="#NASTRAN-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Base.close-Tuple{NASTRANExporter}" href="#Base.close-Tuple{NASTRANExporter}"><code>Base.close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">close(self::NASTRANExporter)</code></pre><p>Close  the stream opened by the exporter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L1066-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK-Tuple{NASTRANExporter}" href="#FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK-Tuple{NASTRANExporter}"><code>FinEtools.MeshExportModule.NASTRAN.BEGIN_BULK</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BEGIN_BULK(self::NASTRANExporter)</code></pre><p>Terminate the Case Control section by starting the bulk section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L1000-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.CEND-Tuple{NASTRANExporter}" href="#FinEtools.MeshExportModule.NASTRAN.CEND-Tuple{NASTRANExporter}"><code>FinEtools.MeshExportModule.NASTRAN.CEND</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CEND(self::NASTRANExporter)</code></pre><p>Terminate the Executive Control section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L991-L995">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.ENDDATA-Tuple{NASTRANExporter}" href="#FinEtools.MeshExportModule.NASTRAN.ENDDATA-Tuple{NASTRANExporter}"><code>FinEtools.MeshExportModule.NASTRAN.ENDDATA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ENDDATA(self::NASTRANExporter)</code></pre><p>Terminate the bulk section.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L1009-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.GRID-Tuple{NASTRANExporter,Int64,Array{Float64,1}}" href="#FinEtools.MeshExportModule.NASTRAN.GRID-Tuple{NASTRANExporter,Int64,Array{Float64,1}}"><code>FinEtools.MeshExportModule.NASTRAN.GRID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GRID(self::NASTRANExporter, n::Int, xyz::Vector{FFlt})</code></pre><p>Write a grid-point statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L1018-L1022">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.MAT1" href="#FinEtools.MeshExportModule.NASTRAN.MAT1"><code>FinEtools.MeshExportModule.NASTRAN.MAT1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">MAT1(self::NASTRANExporter, mid::Int, E::FFlt, nu::FFlt, rho::FFlt = 0.0, A::FFlt = 0.0, TREF::FFlt = 0.0)</code></pre><p>Write a statement for an isotropic elastic material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L1045-L1049">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.MAT1-Tuple{NASTRANExporter,Int64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}" href="#FinEtools.MeshExportModule.NASTRAN.MAT1-Tuple{NASTRANExporter,Int64,Float64,Float64,Float64,Float64,Float64,Float64,Float64}"><code>FinEtools.MeshExportModule.NASTRAN.MAT1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MAT1(self::NASTRANExporter, mid::Int, E::FFlt, G::FFlt, nu::FFlt, rho::FFlt, A::FFlt, TREF::FFlt, GE::FFlt)</code></pre><p>Write a statement for an isotropic elastic material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L1036-L1040">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRAN.PSOLID-Tuple{NASTRANExporter,Int64,Int64}" href="#FinEtools.MeshExportModule.NASTRAN.PSOLID-Tuple{NASTRANExporter,Int64,Int64}"><code>FinEtools.MeshExportModule.NASTRAN.PSOLID</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PSOLID(self::NASTRANExporter, pid::Int, mid::Int)</code></pre><p>Write solid-property statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L1027-L1031">source</a></section></article><h4 id="STL-1"><a class="docs-heading-anchor" href="#STL-1">STL</a><a class="docs-heading-anchor-permalink" href="#STL-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Base.close-Tuple{STLExporter}" href="#Base.close-Tuple{STLExporter}"><code>Base.close</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">close(self::STLExporter)</code></pre><p>Close  the stream opened by the exporter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L1126-L1130">source</a></section></article><h4 id="CSV-1"><a class="docs-heading-anchor" href="#CSV-1">CSV</a><a class="docs-heading-anchor-permalink" href="#CSV-1" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MeshExportModule.CSV.savecsv-Tuple{String}" href="#FinEtools.MeshExportModule.CSV.savecsv-Tuple{String}"><code>FinEtools.MeshExportModule.CSV.savecsv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">savecsv(name::String; kwargs...)</code></pre><p>Save arrays as a CSV file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MeshExportModule.jl#L920-L924">source</a></section></article><h4 id="H2Lib-1"><a class="docs-heading-anchor" href="#H2Lib-1">H2Lib</a><a class="docs-heading-anchor-permalink" href="#H2Lib-1" title="Permalink"></a></h4><h2 id="Vector-cache-utilities-1"><a class="docs-heading-anchor" href="#Vector-cache-utilities-1">Vector-cache utilities</a><a class="docs-heading-anchor-permalink" href="#Vector-cache-utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.VectorCacheModule.settime!-Tuple{VectorCache,Float64}" href="#FinEtools.VectorCacheModule.settime!-Tuple{VectorCache,Float64}"><code>FinEtools.VectorCacheModule.settime!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">settime!(self::VectorCache, time::FFlt)</code></pre><p>Set the current time for the vector cache.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/VectorCacheModule.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.VectorCacheModule.updateretrieve!-Tuple{VectorCache,Array{Float64,2},Array{Float64,2},Int64}" href="#FinEtools.VectorCacheModule.updateretrieve!-Tuple{VectorCache,Array{Float64,2},Array{Float64,2},Int64}"><code>FinEtools.VectorCacheModule.updateretrieve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateretrieve!(self::VectorCache, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>Update the cache and retrieve the vector.</p><p>After the return from this function the updated vector can be read from the cache as <code>self.cache</code> (also returned). If the vector depends on time, the vector cache time first needs to be set as</p><pre><code class="language-none">settime!(c, t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/VectorCacheModule.jl#L99-L110">source</a></section></article><h2 id="Surface-normal-utilities-1"><a class="docs-heading-anchor" href="#Surface-normal-utilities-1">Surface-normal utilities</a><a class="docs-heading-anchor-permalink" href="#Surface-normal-utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.updatenormal!-Tuple{SurfaceNormal,Array{Float64,2},Array{Float64,2},Int64}" href="#FinEtools.SurfaceNormalModule.updatenormal!-Tuple{SurfaceNormal,Array{Float64,2},Array{Float64,2},Int64}"><code>FinEtools.SurfaceNormalModule.updatenormal!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updatenormal!(self::SurfaceNormal, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>Update the surface normal vector.</p><p>Returns a vector (stored in the cache).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/SurfaceNormalModule.jl#L103-L109">source</a></section></article><h2 id="Force-intensity-1"><a class="docs-heading-anchor" href="#Force-intensity-1">Force intensity</a><a class="docs-heading-anchor-permalink" href="#Force-intensity-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.ForceIntensityModule.updateforce!-Tuple{ForceIntensity,Array{Float64,2},Array{Float64,2},Int64}" href="#FinEtools.ForceIntensityModule.updateforce!-Tuple{ForceIntensity,Array{Float64,2},Array{Float64,2},Int64}"><code>FinEtools.ForceIntensityModule.updateforce!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">updateforce!(self::ForceIntensity, ndofn::FInt, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>Update the force intensity vector.</p><p>Returns a vector (stored in the cache <code>self.cache</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/ForceIntensityModule.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.VectorCacheModule.settime!-Tuple{ForceIntensity,Float64}" href="#FinEtools.VectorCacheModule.settime!-Tuple{ForceIntensity,Float64}"><code>FinEtools.VectorCacheModule.settime!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">settime!(self::ForceIntensity, time::FFlt)</code></pre><p>Set the current time for the force intensity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/ForceIntensityModule.jl#L144-L148">source</a></section></article><h2 id="Rotation-utilities-1"><a class="docs-heading-anchor" href="#Rotation-utilities-1">Rotation utilities</a><a class="docs-heading-anchor-permalink" href="#Rotation-utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FinEtools.RotationUtilModule.rotmat3!-Union{Tuple{T}, Tuple{Array{Float64,2},T}} where T" href="#FinEtools.RotationUtilModule.rotmat3!-Union{Tuple{T}, Tuple{Array{Float64,2},T}} where T"><code>FinEtools.RotationUtilModule.rotmat3!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotmat3!(Rmout::FFltMat, a::T) where {T}</code></pre><p>Compute a 3D rotation matrix in-place.</p><p><code>a</code> = array, vector, or tuple with three floating-point numbers</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/RotationUtilModule.jl#L13-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.RotationUtilModule.rotmat3-Union{Tuple{T}, Tuple{T}} where T" href="#FinEtools.RotationUtilModule.rotmat3-Union{Tuple{T}, Tuple{T}} where T"><code>FinEtools.RotationUtilModule.rotmat3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotmat3(a::T) where {T}</code></pre><p>Prepare a rotation matrix from a rotation vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/RotationUtilModule.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.RotationUtilModule.skewmat!-Tuple{Any,Any}" href="#FinEtools.RotationUtilModule.skewmat!-Tuple{Any,Any}"><code>FinEtools.RotationUtilModule.skewmat!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">skewmat!(S, theta)</code></pre><p>Compute skew-symmetric matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/RotationUtilModule.jl#L67-L71">source</a></section></article><h2 id="FEM-machines-1"><a class="docs-heading-anchor" href="#FEM-machines-1">FEM machines</a><a class="docs-heading-anchor-permalink" href="#FEM-machines-1" title="Permalink"></a></h2><h3 id="Base-1"><a class="docs-heading-anchor" href="#Base-1">Base</a><a class="docs-heading-anchor-permalink" href="#Base-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.associategeometry!-Tuple{AbstractFEMM,NodalField{Float64}}" href="#FinEtools.FEMMBaseModule.associategeometry!-Tuple{AbstractFEMM,NodalField{Float64}}"><code>FinEtools.FEMMBaseModule.associategeometry!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">associategeometry!(self::AbstractFEMM,  geom::NodalField{FFlt})</code></pre><p>Associate geometry field with the FEMM.</p><p>There may be operations that could benefit from pre-computations that involve a geometry field. If so, associating the geometry field gives the FEMM a chance to save on repeated computations.</p><p>Geometry field is normally passed into any routine that evaluates some forms (integrals) over the mesh.  Whenever the geometry passed into a routine is not consistent with the one for which <code>associategeometry!()</code> was called before, <code>associategeometry!()</code> needs to be called with the new geometry field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L53-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.connectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM,Int64}} where FEMM&lt;:AbstractFEMM" href="#FinEtools.FEMMBaseModule.connectionmatrix-Union{Tuple{FEMM}, Tuple{FEMM,Int64}} where FEMM&lt;:AbstractFEMM"><code>FinEtools.FEMMBaseModule.connectionmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">connectionmatrix(self::FEMM, nnodes::FInt) where {FEMM&lt;:AbstractFEMM}</code></pre><p>Compute the connection matrix.</p><p>The matrix has a nonzero in all the rows and columns which correspond to nodes connected by some finite element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L435-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.distribloads-Union{Tuple{A}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,A,NodalField{Float64},NodalField{T},ForceIntensity,Int64}} where A&lt;:AbstractSysvecAssembler where T&lt;:Number where FEMM&lt;:AbstractFEMM" href="#FinEtools.FEMMBaseModule.distribloads-Union{Tuple{A}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,A,NodalField{Float64},NodalField{T},ForceIntensity,Int64}} where A&lt;:AbstractSysvecAssembler where T&lt;:Number where FEMM&lt;:AbstractFEMM"><code>FinEtools.FEMMBaseModule.distribloads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distribloads(self::FEMM, assembler::A, geom::NodalField{FFlt}, P::NodalField{T},
  fi::ForceIntensity,
  m::FInt) where {FEMM&lt;:AbstractFEMM, T&lt;:Number, A&lt;:AbstractSysvecAssembler}</code></pre><p>Compute the distributed-load vector.</p><p><strong>Arguments</strong></p><ul><li><code>fi</code>=force intensity object</li><li><code>m</code>= manifold dimension, 1= curve, 2= surface, 3= volume. For body loads <code>m</code></li></ul><p>is set to 3, for tractions on the surface it is set to 2, and so on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L374-L385">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.elemfieldfromintegpoints-Union{Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Symbol,Array{Int64,1}}} where T&lt;:Number where FEMM&lt;:AbstractFEMM" href="#FinEtools.FEMMBaseModule.elemfieldfromintegpoints-Union{Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Symbol,Array{Int64,1}}} where T&lt;:Number where FEMM&lt;:AbstractFEMM"><code>FinEtools.FEMMBaseModule.elemfieldfromintegpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elemfieldfromintegpoints(self::FEMM,
  geom::NodalField{FFlt},  u::NodalField{T},
  dT::NodalField{FFlt},  quantity::Symbol,  component::FInt;
  context...) where {FEMM&lt;:AbstractFEMM, T&lt;:Number}</code></pre><p>Construct elemental field from integration points.</p><p><strong>Arguments</strong></p><p><code>geom</code>     - reference geometry field <code>u</code>        - displacement field <code>dT</code>       - temperature difference field <code>quantity</code>   - this is what you would assign to the &#39;quantity&#39; argument            of the material update!() method. <code>component</code>- component of the &#39;quantity&#39; array: see the material update()            method.</p><p><strong>Output</strong></p><ul><li>the new field that can be used to map values to colors and so on</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L646-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.fieldfromintegpoints-Union{Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Symbol,Array{Int64,1}}} where T&lt;:Number where FEMM&lt;:AbstractFEMM" href="#FinEtools.FEMMBaseModule.fieldfromintegpoints-Union{Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},NodalField{T},NodalField{Float64},Symbol,Array{Int64,1}}} where T&lt;:Number where FEMM&lt;:AbstractFEMM"><code>FinEtools.FEMMBaseModule.fieldfromintegpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fieldfromintegpoints(self::FEMM,
  geom::NodalField{FFlt},  u::NodalField{T},
  dT::NodalField{FFlt},  quantity::Symbol,  component::FInt;
  context...) where {FEMM&lt;:AbstractFEMM, T&lt;:Number}</code></pre><p>Construct nodal field from integration points.</p><p><strong>Arguments</strong></p><ul><li><code>geom</code>     - reference geometry field</li><li><code>u</code>        - displacement field</li><li><code>dT</code>       - temperature difference field</li><li><code>quantity</code>   - this is what you would assign to the &#39;quantity&#39; argument          of the material update!() method.</li><li><code>component</code>- component of the &#39;quantity&#39; array: see the material update()          method.</li></ul><p>Keyword arguments</p><ul><li><code>nodevalmethod</code> = <code>:invdistance</code> (the default) or <code>:averaging</code>;</li><li><code>reportat</code> = at which point should the  element quantities be reported?   This argument is interpreted inside the <code>inspectintegpoints()</code> method.</li></ul><p><strong>Output</strong></p><ul><li>the new field that can be used to map values to colors and so on</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L522-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.innerproduct-Union{Tuple{T}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM,A,NodalField{Float64},NodalField{T}}} where T where A&lt;:AbstractSysmatAssembler where FEMM&lt;:AbstractFEMM" href="#FinEtools.FEMMBaseModule.innerproduct-Union{Tuple{T}, Tuple{A}, Tuple{FEMM}, Tuple{FEMM,A,NodalField{Float64},NodalField{T}}} where T where A&lt;:AbstractSysmatAssembler where FEMM&lt;:AbstractFEMM"><code>FinEtools.FEMMBaseModule.innerproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">innerproduct(self::FEMMHeatDiff,
  assembler::A, geom::NodalField{FFlt},
  temp::NodalField{FFlt}) where {A&lt;:AbstractSysmatAssembler}</code></pre><p>Compute the inner-product (Gram) matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L750-L756">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMM,NodalField{Float64},Array{Int64,1},F,Any,Any}} where F&lt;:Function where T&lt;:Number where FEMM&lt;:AbstractFEMM" href="#FinEtools.FEMMBaseModule.inspectintegpoints-Union{Tuple{F}, Tuple{T}, Tuple{FEMM}, Tuple{FEMM,NodalField{Float64},Array{Int64,1},F,Any}, Tuple{FEMM,NodalField{Float64},Array{Int64,1},F,Any,Any}} where F&lt;:Function where T&lt;:Number where FEMM&lt;:AbstractFEMM"><code>FinEtools.FEMMBaseModule.inspectintegpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inspectintegpoints(self::FEMM, geom::NodalField{FFlt},  u::NodalField{T}, dT::NodalField{FFlt}, felist::FIntVec, inspector::F,  idat, quantity=:Cauchy; context...) where {FEMM&lt;:AbstractFEMM, T&lt;:Number, F&lt;:Function}</code></pre><p>Inspect integration points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{F}, Tuple{R}, Tuple{FL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},FL,F,R}} where F&lt;:Function where R where FL&lt;:ElementalField{T} where T&lt;:Number" href="#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{F}, Tuple{R}, Tuple{FL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},FL,F,R}} where F&lt;:Function where R where FL&lt;:ElementalField{T} where T&lt;:Number"><code>FinEtools.FEMMBaseModule.integratefieldfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integratefieldfunction(self::AbstractFEMM,
    geom::NodalField{FFlt},  afield::FL, fh::F, initial::R;
    m::FInt=-1) where {T&lt;:Number, FL&lt;:ElementalField{T}, R, F&lt;:Function}</code></pre><p>Integrate a elemental-field function over the discrete manifold.</p><p><code>afield</code> = ELEMENTAL field to be supply the values <code>fh</code> = function taking position and the field value as arguments, returning value of type <code>R</code>.</p><p>Returns value of type <code>R</code>, which is initialized by <code>initial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L128-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{F}, Tuple{R}, Tuple{FL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},FL,F,R}} where F&lt;:Function where R where FL&lt;:NodalField{T} where T&lt;:Number" href="#FinEtools.FEMMBaseModule.integratefieldfunction-Union{Tuple{F}, Tuple{R}, Tuple{FL}, Tuple{T}, Tuple{AbstractFEMM,NodalField{Float64},FL,F,R}} where F&lt;:Function where R where FL&lt;:NodalField{T} where T&lt;:Number"><code>FinEtools.FEMMBaseModule.integratefieldfunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integratefieldfunction(self::AbstractFEMM,
    geom::NodalField{FFlt},  afield::FL, fh::F,  initial::R;
    m::FInt=-1) where {T&lt;:Number, FL&lt;:NodalField{T}, R, F&lt;:Function}</code></pre><p>Integrate a nodal-field function over the discrete manifold.</p><p><code>afield</code> = NODAL field to be supply the values <code>fh</code> = function taking position and the field value as arguments, returning value of type <code>R</code>.</p><p>Returns value of type <code>R</code>, which is initialized by <code>initial</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L81-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.integratefunction-Union{Tuple{F}, Tuple{AbstractFEMM,NodalField{Float64},F}, Tuple{AbstractFEMM,NodalField{Float64},F,Int64}} where F&lt;:Function" href="#FinEtools.FEMMBaseModule.integratefunction-Union{Tuple{F}, Tuple{AbstractFEMM,NodalField{Float64},F}, Tuple{AbstractFEMM,NodalField{Float64},F,Int64}} where F&lt;:Function"><code>FinEtools.FEMMBaseModule.integratefunction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integratefunction(self::AbstractFEMM,
    geom::NodalField{FFlt}, fh::F, m::FInt = -1) where {F&lt;:Function}</code></pre><p>Integrate a function over the discrete manifold.</p><p>Integrate some scalar function over the geometric cells. The function takes a single argument, the position vector.</p><p>When the scalar function returns just +1 (such as <code>(x) -&gt;  1.0</code>), the result measures the volume (number of points, length, area, 3-D volume, according to the manifold dimension). When the function returns the mass density, the method measures the mass, when the function returns the x-coordinate equal measure the static moment with respect to the y- axis, and so on.</p><p><strong>Example:</strong></p><p>Compute the volume of the mesh and then its center of gravity:</p><pre><code class="language-none">V = integratefunction(femm, geom, (x) -&gt;  1.0)
Sx = integratefunction(femm, geom, (x) -&gt;  x[1])
Sy = integratefunction(femm, geom, (x) -&gt;  x[2])
Sz = integratefunction(femm, geom, (x) -&gt;  x[3])
CG = vec([Sx Sy Sz]/V)</code></pre><p>Compute a moment of inertia of the mesh relative to the origin:</p><pre><code class="language-none">Ixx = integratefunction(femm, geom, (x) -&gt;  x[2]^2 + x[3]^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L173-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{F,FENodeSet,AbstractFESet,F,FENodeSet,AbstractFESet,Float64}} where F&lt;:ElementalField{T} where T&lt;:Number" href="#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{F,FENodeSet,AbstractFESet,F,FENodeSet,AbstractFESet,Float64}} where F&lt;:ElementalField{T} where T&lt;:Number"><code>FinEtools.FEMMBaseModule.transferfield!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transferfield!(ff::F, fensf::FENodeSet, fesf::AbstractFESet, fc::F,
    fensc::FENodeSet, fesc::AbstractFESet, geometricaltolerance::FFlt;
    parametrictolerance::FFlt = 0.01 )  where {T&lt;:Number,
    F&lt;:ElementalField{T}}</code></pre><p>Transfer an elemental field from a coarse mesh to a finer one.</p><p><strong>Arguments</strong></p><ul><li><code>ff</code> = the fine-mesh field (modified and also returned)</li><li><code>fensf</code> = finite element node set for the fine-mesh</li><li><code>fc</code> = the coarse-mesh field</li><li><code>fensc</code> = finite element node set for the fine-mesh,</li><li><code>fesc</code> = finite element set for the coarse mesh</li><li><code>tolerance</code> = tolerance in physical space for searches of the adjacent nodes</li></ul><p><strong>Output</strong></p><p>Elemental field <code>ff</code> transferred to the fine mesh is output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L319-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{F,FENodeSet,AbstractFESet,F,FENodeSet,AbstractFESet,Float64}} where F&lt;:NodalField{T} where T&lt;:Number" href="#FinEtools.FEMMBaseModule.transferfield!-Union{Tuple{F}, Tuple{T}, Tuple{F,FENodeSet,AbstractFESet,F,FENodeSet,AbstractFESet,Float64}} where F&lt;:NodalField{T} where T&lt;:Number"><code>FinEtools.FEMMBaseModule.transferfield!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transferfield!(ff::F, fensf::FENodeSet, fesf::AbstractFESet,
    fc::F, fensc::FENodeSet, fesc::AbstractFESet, tolerance::FFlt
    )  where {T&lt;:Number, F&lt;:NodalField{T}}</code></pre><p>Transfer a nodal field from a coarse mesh to a finer one.</p><p><strong>Arguments</strong></p><ul><li><code>ff</code> = the fine-mesh field (modified and also returned)</li><li><code>fensf</code> = finite element node set for the fine-mesh</li><li><code>fc</code> = the coarse-mesh field</li><li><code>fensc</code> = finite element node set for the fine-mesh,</li><li><code>fesc</code> = finite element set for the coarse mesh</li><li><code>geometricaltolerance</code> = tolerance in physical space for searches of the adjacent nodes</li><li><code>parametrictolerance</code> = tolerance in parametric space for for check whether node is inside an element</li></ul><p><strong>Output</strong></p><p>Nodal field <code>ff</code> transferred to the fine mesh is output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/FEMMBaseModule.jl#L229-L249">source</a></section></article><h2 id="Algorithms-1"><a class="docs-heading-anchor" href="#Algorithms-1">Algorithms</a><a class="docs-heading-anchor-permalink" href="#Algorithms-1" title="Permalink"></a></h2><h3 id="Base-2"><a class="docs-heading-anchor" href="#Base-2">Base</a><a class="docs-heading-anchor-permalink" href="#Base-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.bisect-NTuple{5,Any}" href="#FinEtools.AlgoBaseModule.bisect-NTuple{5,Any}"><code>FinEtools.AlgoBaseModule.bisect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bisect(fun, xl, xu, tolx, tolf)</code></pre><p>Implementation of the bisection method.</p><p>Tolerance both on <code>x</code> and on <code>f(x)</code> is used.</p><ul><li><code>fun</code> = function,</li><li><code>xl</code>= lower value of the bracket,</li><li><code>xu</code>= upper Value of the bracket,</li><li><code>tolx</code>= tolerance on the location of the root,</li><li><code>tolf</code>= tolerance on the function value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L128-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.conjugategradient-Union{Tuple{T}, Tuple{T,Array{Float64,1},Array{Float64,1},Int64}} where T" href="#FinEtools.AlgoBaseModule.conjugategradient-Union{Tuple{T}, Tuple{T,Array{Float64,1},Array{Float64,1},Int64}} where T"><code>FinEtools.AlgoBaseModule.conjugategradient</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conjugategradient(A, b, x0, maxiter)</code></pre><p>Compute one or more iterations of the conjugate gradient process.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L284-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.evalconvergencestudy-Tuple{Any}" href="#FinEtools.AlgoBaseModule.evalconvergencestudy-Tuple{Any}"><code>FinEtools.AlgoBaseModule.evalconvergencestudy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evalconvergencestudy(modeldatasequence)</code></pre><p>Evaluate a convergence study from a model-data sequence.  </p><p><code>modeldatasequence</code> = array of <code>modeldata</code> dictionaries.</p><p>Refer to methods <code>fieldnorm</code> and <code>fielddiffnorm</code> for details on the required keys in the dictionaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L253-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.fielddiffnorm-Tuple{Any,Any}" href="#FinEtools.AlgoBaseModule.fielddiffnorm-Tuple{Any,Any}"><code>FinEtools.AlgoBaseModule.fielddiffnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fielddiffnorm(modeldatacoarse, modeldatafine)</code></pre><p>Compute norm of the difference of the target fields.  </p><p><strong>Arguments</strong></p><p>For both the &quot;coarse&quot;- and &quot;fine&quot;-mesh <code>modeldata</code> the data dictionaries need to contain the mandatory keys:</p><ul><li><code>&quot;fens&quot;</code> = finite element node set</li><li><code>&quot;regions&quot;</code> = array of regions</li><li><code>&quot;targetfields&quot;</code> = array of fields, one for each region</li><li><code>&quot;geom&quot;</code> = geometry field</li><li><code>&quot;elementsize&quot;</code> = representative element size,</li><li><code>&quot;geometricaltolerance&quot;</code> = geometrical tolerance (used in field transfer; refer to the documentation of <code>transferfield!</code>)</li><li><code>&quot;parametrictolerance&quot;</code> = parametric tolerance (used in field transfer; refer to the documentation of <code>transferfield!</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L196-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.fieldnorm-Tuple{Any}" href="#FinEtools.AlgoBaseModule.fieldnorm-Tuple{Any}"><code>FinEtools.AlgoBaseModule.fieldnorm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fieldnorm(modeldata)</code></pre><p>Compute norm of the target field.  </p><p><strong>Argument</strong></p><p><code>modeldata</code> = data dictionary, mandatory keys:     - &quot;fens&quot; = finite element node set     - &quot;regions&quot; = array of regions     - &quot;targetfields&quot; = array of fields, one for each region     - &quot;geom&quot; = geometry field     - &quot;elementsize&quot; = representative element size,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L166-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.penaltyebc!-NTuple{5,Any}" href="#FinEtools.AlgoBaseModule.penaltyebc!-NTuple{5,Any}"><code>FinEtools.AlgoBaseModule.penaltyebc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">penaltyebc!(K, F, dofnums, prescribedvalues, penfact)</code></pre><p>Apply penalty essential boundary conditions.</p><p><strong>Arguments</strong></p><ul><li><code>K</code> = stiffness matrix</li><li><code>F</code> = global load vector </li><li><code>dofnums</code>, <code>prescribedvalues</code> = arrays computed by <code>prescribeddofs()</code></li><li><code>penfact</code> = penalty multiplier, in relative terms: how many times the maximum</li></ul><pre><code class="language-none">absolute value of the diagonal elements should the penalty term be?</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L362-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.qcovariance-Tuple{Any,Any,Any}" href="#FinEtools.AlgoBaseModule.qcovariance-Tuple{Any,Any,Any}"><code>FinEtools.AlgoBaseModule.qcovariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qcovariance(ps, xs, ys; ws = nothing)</code></pre><p>Compute the covariance for two &#39;functions&#39; given by the arrays <code>xs</code> and <code>ys</code>  at the values of the parameter <code>ps</code>. <code>ws</code> is the optional weights vector;   if it is not supplied, uniformly distributed default weights are assumed.  </p><p>Notes:  – The mean is subtracted from both functions.  – This function is not particularly efficient: it computes the mean of  both functions and it allocates arrays instead of overwriting the  contents of the arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L326-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.qtrap-Tuple{Any,Any}" href="#FinEtools.AlgoBaseModule.qtrap-Tuple{Any,Any}"><code>FinEtools.AlgoBaseModule.qtrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qtrap(ps, xs)</code></pre><p>Compute the area under the curve given by a set of parameters along  an interval and the values of the &#39;function&#39; at those parameter values.   The parameter values need not be uniformly distributed.</p><p>Trapezoidal rule is used to evaluate the integral. The &#39;function&#39; is  assumed to vary linearly inbetween the given points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L307-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.qvariance-Tuple{Any,Any}" href="#FinEtools.AlgoBaseModule.qvariance-Tuple{Any,Any}"><code>FinEtools.AlgoBaseModule.qvariance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qvariance(ps, xs; ws = nothing)</code></pre><p>Compute the variance of a function given by the array <code>xs</code> at  the values of the parameter <code>ps</code>. <code>ws</code> is the optional weights vector   with unit default weights.    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L353-L359">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.richextrapol-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{Tn,N} where N where Tn)" href="#FinEtools.AlgoBaseModule.richextrapol-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{Tn,N} where N where Tn)"><code>FinEtools.AlgoBaseModule.richextrapol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">richextrapol(solns::T, params::T) where {T&lt;:AbstractArray{Tn} where {Tn}}</code></pre><p>Richardson extrapolation.</p><p><strong>Arguments</strong></p><ul><li><code>solns</code> =  array of three solution values</li><li><code>params</code> = array of values of three parameters for which the <code>solns</code> have been obtained</li></ul><p>This function is applicable to any the mesh sizes (monotonically increasing, or decreasing).</p><p><strong>Output</strong></p><ul><li><code>solnestim</code>= estimate of the asymptotic solution from the data points in the <code>solns</code> array</li><li><code>beta</code>= convergence rate</li><li><code>c</code> = constant in the estimate <code>error=c*h^beta</code></li><li><code>residual</code> = residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L40-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FinEtools.AlgoBaseModule.richextrapoluniform-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{Tn,N} where N where Tn)" href="#FinEtools.AlgoBaseModule.richextrapoluniform-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(AbstractArray{Tn,N} where N where Tn)"><code>FinEtools.AlgoBaseModule.richextrapoluniform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">richextrapoluniform(solns::T, params::T) where {T&lt;:AbstractArray{Tn} where {Tn}}</code></pre><p>Richardson extrapolation.</p><p><strong>Argument</strong></p><ul><li><code>solns</code> =  array of solution values</li><li><code>params</code> = array of values of parameters for which the <code>solns</code> have been obtained. This function is applicable only to fixed (uniform) ratio between the mesh sizes, <code>params[1]/params[2) = params[2)/params[3)</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>solnestim</code>= estimate of the asymptotic solution from the data points in the <code>solns</code> array</li><li><code>beta</code>= convergence rate</li><li><code>c</code> = constant in the estimate <code>error=c*h^beta</code></li><li><code>residual</code> = residual after equations from which the above quantities were solved (this is a measure of how accurately was the system solved).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/AlgoBaseModule.jl#L91-L109">source</a></section></article><h2 id="Material-models-1"><a class="docs-heading-anchor" href="#Material-models-1">Material models</a><a class="docs-heading-anchor-permalink" href="#Material-models-1" title="Permalink"></a></h2><h3 id="Material-model-abstractions-1"><a class="docs-heading-anchor" href="#Material-model-abstractions-1">Material model abstractions</a><a class="docs-heading-anchor-permalink" href="#Material-model-abstractions-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="FinEtools.MatModule.massdensity-Tuple{AbstractMat}" href="#FinEtools.MatModule.massdensity-Tuple{AbstractMat}"><code>FinEtools.MatModule.massdensity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">massdensity(self::AbstractMat)</code></pre><p>Return mass density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/30258bfc12703e04599e34b48542ef485c049b49/src/MatModule.jl#L17-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="types.html">« Types</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 29 February 2020 18:46">Saturday 29 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
