<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · FinEtools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FinEtools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../guide/guide.html">Guide</a></li><li><span class="toctext">Types and Functions</span><ul><li class="current"><a class="toctext" href="types.html">Types</a><ul class="internal"><li><a class="toctext" href="#Coordinate-systems-1">Coordinate systems</a></li><li><a class="toctext" href="#Finite-element-sets-1">Finite element sets</a></li><li><a class="toctext" href="#Finite-element-nodes-1">Finite element nodes</a></li><li><a class="toctext" href="#Finite-element-node-to-element-map-1">Finite element node-to-element map</a></li><li><a class="toctext" href="#Fields-1">Fields</a></li><li><a class="toctext" href="#Integration-rule-1">Integration rule</a></li><li><a class="toctext" href="#Integration-domain-1">Integration domain</a></li><li><a class="toctext" href="#Assembly-of-matrices-and-vectors-1">Assembly of matrices and vectors</a></li><li><a class="toctext" href="#Mesh-import/export-1">Mesh import/export</a></li><li><a class="toctext" href="#Vector-cache-utilities-1">Vector-cache utilities</a></li><li><a class="toctext" href="#Surface-normal-utilities-1">Surface-normal utilities</a></li><li><a class="toctext" href="#Force-intensity-1">Force intensity</a></li><li><a class="toctext" href="#FEM-machines-1">FEM machines</a></li><li><a class="toctext" href="#Material-models-1">Material models</a></li></ul></li><li><a class="toctext" href="functions.html">Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Types and Functions</li><li><a href="types.html">Types</a></li></ul><a class="edit-page" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/master/docs/src/man/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h1><h2><a class="nav-anchor" id="Coordinate-systems-1" href="#Coordinate-systems-1">Coordinate systems</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys" href="#FinEtools.CSysModule.CSys"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CSys{F&lt;:Function}</code></pre><p>Type for coordinate system transformations. Used to define material coordinate systems, and output coordinate systems, for instance.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/CSysModule.jl#L11-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{Array{Float64,2}}" href="#FinEtools.CSysModule.CSys-Tuple{Array{Float64,2}}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CSys(csmat::FFltMat)</code></pre><p>Construct coordinate system when the rotation matrix is given.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/CSysModule.jl#L45-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{Int64,Int64}" href="#FinEtools.CSysModule.CSys-Tuple{Int64,Int64}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CSys(sdim::FInt, mdim::FInt)</code></pre><p>Construct coordinate system for isotropic-material used with isoparametric finite elements.</p><ul><li><code>sdim</code> = number of space dimensions,</li><li><code>mdim</code> = number of manifold dimensions of the finite element in which the coordinate system  is being evaluated.</li></ul><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><p>If  the coordinate system matrix  should be identity, better use the constructor for this specific situation, <code>CSys(dim::FInt)</code>. That will be much more efficient.</p><p><strong>See also</strong></p><p><code>gen_iso_csmat</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/CSysModule.jl#L68-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{Int64}" href="#FinEtools.CSysModule.CSys-Tuple{Int64}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CSys(dim::FInt)</code></pre><p>Construct coordinate system when the rotation matrix is the identity.</p><p><code>dim</code> = is the space dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/CSysModule.jl#L57-L63">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{Int64,Int64,F}} where F&lt;:Function" href="#FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{Int64,Int64,F}} where F&lt;:Function"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CSys(sdim::FInt, mdim::FInt, computecsmat::F) where {F&lt;:Function}</code></pre><p>Construct ccoordinate system when the function to compute the rotation matrix is given.</p><p>The function signature: <code>update!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code> where</p><ul><li><code>csmatout</code>= output matrix buffer, of size <code>(sdim, mdim)</code></li><li><code>XYZ</code>= location  in physical coordinates,</li><li><code>tangents</code>= tangent vector matrix, tangents to the parametric coordinate curves  in the element,</li><li><code>fe_label</code>= finite element label.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/CSysModule.jl#L25-L39">source</a></section><h2><a class="nav-anchor" id="Finite-element-sets-1" href="#Finite-element-sets-1">Finite element sets</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet" href="#FinEtools.FESetModule.AbstractFESet"><code>FinEtools.FESetModule.AbstractFESet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractFESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set. Parameterized with the number of of the nodes per element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet0Manifold" href="#FinEtools.FESetModule.AbstractFESet0Manifold"><code>FinEtools.FESetModule.AbstractFESet0Manifold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractFESet0Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 0-dimensional manifolds (points). Parameterized with the number of of the nodes per element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L21-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet1Manifold" href="#FinEtools.FESetModule.AbstractFESet1Manifold"><code>FinEtools.FESetModule.AbstractFESet1Manifold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractFESet1Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 1-dimensional manifolds (curves). Parameterized with the number of of the nodes per element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L28-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet2Manifold" href="#FinEtools.FESetModule.AbstractFESet2Manifold"><code>FinEtools.FESetModule.AbstractFESet2Manifold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractFESet2Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 2-dimensional manifolds (surfaces). Parameterized with the number of of the nodes per element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L35-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.AbstractFESet3Manifold" href="#FinEtools.FESetModule.AbstractFESet3Manifold"><code>FinEtools.FESetModule.AbstractFESet3Manifold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractFESet3Manifold{NODESPERELEM} &lt;: FESet{NODESPERELEM}</code></pre><p>Abstract type of a finite element set for 3-dimensional manifolds (solids). Parameterized with the number of of the nodes per element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L42-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetH20" href="#FinEtools.FESetModule.FESetH20"><code>FinEtools.FESetModule.FESetH20</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetH20</code></pre><p>Type for sets of volume-like hexahedral finite elements with 20 nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L888-L892">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetH27" href="#FinEtools.FESetModule.FESetH27"><code>FinEtools.FESetModule.FESetH27</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetH27</code></pre><p>Type for sets of volume-like hexahedral finite elements with 27 nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L1033-L1037">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetH8" href="#FinEtools.FESetModule.FESetH8"><code>FinEtools.FESetModule.FESetH8</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetH8</code></pre><p>Type for sets of volume-like hexahedral finite elements with eight nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L821-L825">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetL2" href="#FinEtools.FESetModule.FESetL2"><code>FinEtools.FESetModule.FESetL2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetL2</code></pre><p>Type for sets of curve-like finite elements with two nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L482-L486">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetL3" href="#FinEtools.FESetModule.FESetL3"><code>FinEtools.FESetModule.FESetL3</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetL3</code></pre><p>Type for sets of curve-like of finite elements with three nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L513-L517">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetP1" href="#FinEtools.FESetModule.FESetP1"><code>FinEtools.FESetModule.FESetP1</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetP1</code></pre><p>Type for sets of point-like of finite elements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L451-L455">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ4" href="#FinEtools.FESetModule.FESetQ4"><code>FinEtools.FESetModule.FESetQ4</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetQ4</code></pre><p>Type for sets of surface-like quadrilateral finite elements with four nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L593-L597">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ8" href="#FinEtools.FESetModule.FESetQ8"><code>FinEtools.FESetModule.FESetQ8</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetQ8</code></pre><p>Type for sets of surface-like quadrilateral finite elements with eight nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L694-L698">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ9" href="#FinEtools.FESetModule.FESetQ9"><code>FinEtools.FESetModule.FESetQ9</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetQ9</code></pre><p>Type for sets of surface-like quadrilateral finite elements with nine nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L640-L644">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT10" href="#FinEtools.FESetModule.FESetT10"><code>FinEtools.FESetModule.FESetT10</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetT10</code></pre><p>Type for sets of volume-like tetrahedral finite elements with 10 nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L1202-L1206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT3" href="#FinEtools.FESetModule.FESetT3"><code>FinEtools.FESetModule.FESetT3</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetT3</code></pre><p>Type for sets of surface-like triangular finite elements with three nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L553-L557">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT4" href="#FinEtools.FESetModule.FESetT4"><code>FinEtools.FESetModule.FESetT4</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetT4</code></pre><p>Type for sets of volume-like tetrahedral finite elements with four nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L1155-L1159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT6" href="#FinEtools.FESetModule.FESetT6"><code>FinEtools.FESetModule.FESetT6</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetT6</code></pre><p>Type for sets of surface-like triangular finite elements with six nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FESetModule.jl#L763-L767">source</a></section><h2><a class="nav-anchor" id="Finite-element-nodes-1" href="#Finite-element-nodes-1">Finite element nodes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeSetModule.FENodeSet" href="#FinEtools.FENodeSetModule.FENodeSet"><code>FinEtools.FENodeSetModule.FENodeSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Finite element node set type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FENodeSetModule.jl#L11-L13">source</a></section><h2><a class="nav-anchor" id="Finite-element-node-to-element-map-1" href="#Finite-element-node-to-element-map-1">Finite element node-to-element map</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Map from finite element nodes to the finite elements connecting them.</p><p>For each  node referenced in the connectivity of the finite element set on input, the numbers of the individual finite elements that reference that node is stored in an array in the array <code>map</code>.         Example: </p><pre><code class="language-none">fes.conn= [7,6,5;
            4,1,3;
            3,7,5];
The map reads
    map[1] = [2];
    map[2] = [];#  note that node number 2 is not referenced by the connectivity
    map[3] = [2,3];
    map[4] = [2];
    map[5] = [1,3];
    map[6] = [1];
    map[7] = [1,3];</code></pre><p>The individual elements from the connectivity that reference node number 5 are 1 and 3, so that <code>fes.conn(map[5],:)</code>includes all the nodes that are connected to node 5 (including node 5 itself).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FENodeToFEMapModule.jl#L10-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap-Tuple{Array{Int64,2},Int64}" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Tuple{Array{Int64,2},Int64}"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">FENodeToFEMap(conns::FIntMat, nmax::FInt)</code></pre><p>Map from finite element nodes to the finite elements connecting them.</p><ul><li><code>conns</code> = integer array of the connectivities</li><li><code>nmax</code> = largest possible node number</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FENodeToFEMapModule.jl#L66-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT,N}},1},Int64}} where IT&lt;:Integer where N" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT,N}},1},Int64}} where IT&lt;:Integer where N"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">FENodeToFEMap(conn::Vector{NTuple{N, IT}}, nmax::FInt) where {N, IT&lt;:Integer}</code></pre><p>Map from finite element nodes to the finite elements connecting them.</p><ul><li><code>conns</code> = connectivities as a vector of tuples</li><li><code>nmax</code> = largest possible node number</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FENodeToFEMapModule.jl#L44-L51">source</a></section><h2><a class="nav-anchor" id="Fields-1" href="#Fields-1">Fields</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.AbstractField" href="#FinEtools.FieldModule.AbstractField"><code>FinEtools.FieldModule.AbstractField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractField</code></pre><p>Abstract field.</p><p>Expected  attributes:</p><ul><li><code>values::FMat{T}</code>: Array of degree of freedom parameters,  indexed by entity number</li><li><code>dofnums::FIntMat</code>: Array of degree of freedom numbers, indexed by entity number</li><li><code>is_fixed::Matrix{Bool}</code>: Array of Boolean flags, indexed by entity number</li><li><code>fixed_values::FMat{T}</code>: Array of fixed values, indexed by entity number</li><li><code>nfreedofs::FInt</code>: Total number of free degrees of freedom</li></ul><p>See also: <a href="man/@ref"><code>@add_Field_fields()</code></a> .</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FieldModule.jl#L11-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField" href="#FinEtools.GeneralFieldModule.GeneralField"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GeneralField{T&lt;:Number} &lt;: AbstractField</code></pre><p>General field, meaning the entities can be anything.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/GeneralFieldModule.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">GeneralField(data::FVec{T}) where {T&lt;:Number}</code></pre><p>Constructor of general field.  The values of the field are given by the vector on input, <code>data</code>. This vector needs to have as many rows as there are entities.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/GeneralFieldModule.jl#L39-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">GeneralField(data::FMat{T}=[]) where {T&lt;:Number}</code></pre><p>Constructor of general field.  The values of the field are given by the array on input, <code>data</code>. This array needs to have as many rows as there are entities, and as many columns as there are degrees of freedom per entities.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/GeneralFieldModule.jl#L22-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField" href="#FinEtools.NodalFieldModule.NodalField"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NodalField{T&lt;:Number} &lt;: AbstractField</code></pre><p>Nodal field, meaning the entities are the finite element nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/NodalFieldModule.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.NodalFieldModule.NodalField-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">NodalField(data::FVec{T}) where {T&lt;:Number}</code></pre><p>Constructor of nodal field. The values of the field are given by the vector on input, <code>data</code>. This vector needs to have as many entries as there are nodes; there is just one degree of freedom per nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/NodalFieldModule.jl#L38-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.NodalFieldModule.NodalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">NodalField(data::FMat{T}=[]) where {T&lt;:Number}</code></pre><p>Constructor of nodal field. The values of the field are given by the array on input, <code>data</code>. This array needs to have as many rows as there are nodes, and as many columns as there are degrees of freedom per node.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/NodalFieldModule.jl#L21-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField" href="#FinEtools.ElementalFieldModule.ElementalField"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ElementalField{T&lt;:Number} &lt;: AbstractField</code></pre><p>Elemental field, meaning the entities are finite elements.</p><p>The values in the field are indexed by the element number.  This means  that there needs to be one field per finite element set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/ElementalFieldModule.jl#L13-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ElementalField(data::FVec{T}) where {T&lt;:Number}</code></pre><p>Constructor of elemental field. The values of the field are given by the vector on input, <code>data</code>. This vector needs to have as many entries as there are elements; there is just one degree of freedom per element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/ElementalFieldModule.jl#L42-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>ElementalField(data::FMat{T}=[]) where {T&lt;:Number}</p><p>Constructor of elemental field. The values of the field are given by the array on input, <code>data</code>. This array needs to have as many rows as there are elements, and as many columns as there are degrees of freedom per element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/ElementalFieldModule.jl#L25-L31">source</a></section><h2><a class="nav-anchor" id="Integration-rule-1" href="#Integration-rule-1">Integration rule</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.AbstractIntegRule" href="#FinEtools.IntegRuleModule.AbstractIntegRule"><code>FinEtools.IntegRuleModule.AbstractIntegRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractIntegRule</code></pre><p>Abstract type for integration rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.GaussRule" href="#FinEtools.IntegRuleModule.GaussRule"><code>FinEtools.IntegRuleModule.GaussRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GaussRule &lt;: AbstractIntegRule</code></pre><p>The Gauss rul, applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L158-L162">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.GaussRule" href="#FinEtools.IntegRuleModule.GaussRule"><code>FinEtools.IntegRuleModule.GaussRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GaussRule(dim=1, order=1)</code></pre><p>Gauss rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L171-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalSimplexRule" href="#FinEtools.IntegRuleModule.NodalSimplexRule"><code>FinEtools.IntegRuleModule.NodalSimplexRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NodalSimplexRule &lt;: AbstractIntegRule</code></pre><p>The nodal-quadrature simplex rule.</p><p>The rule is applicable for line segments, triangles, tetrahedra.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><p>The quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L492-L503">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalSimplexRule" href="#FinEtools.IntegRuleModule.NodalSimplexRule"><code>FinEtools.IntegRuleModule.NodalSimplexRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NodalSimplexRule(dim=1)</code></pre><p>Nodal-quadrature simplex rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L511-L515">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalTensorProductRule" href="#FinEtools.IntegRuleModule.NodalTensorProductRule"><code>FinEtools.IntegRuleModule.NodalTensorProductRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NodalTensorProductRule &lt;: AbstractIntegRule</code></pre><p>The tensor-product nodal-quadrature rule.</p><p>The rule is applicable for line segments, quadrilaterals, hexahedra.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"></div></div><p>The quadrature points for a nodal quadrature rule must be listed in the order  in which the nodes are used in the definition of the element!</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L533-L544">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalTensorProductRule" href="#FinEtools.IntegRuleModule.NodalTensorProductRule"><code>FinEtools.IntegRuleModule.NodalTensorProductRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NodalTensorProductRule(dim=1)</code></pre><p>Nodal-quadrature tensor-product rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L552-L556">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.PointRule" href="#FinEtools.IntegRuleModule.PointRule"><code>FinEtools.IntegRuleModule.PointRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PointRule &lt;: AbstractIntegRule</code></pre><p>Point quadrature rule, used for integration on the standard &quot;point&quot; shape.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L371-L375">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.PointRule-Tuple{}" href="#FinEtools.IntegRuleModule.PointRule-Tuple{}"><code>FinEtools.IntegRuleModule.PointRule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">PointRule()</code></pre><p>POINT integration rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L382-L386">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.SimplexRule" href="#FinEtools.IntegRuleModule.SimplexRule"><code>FinEtools.IntegRuleModule.SimplexRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimplexRule &lt;: AbstractIntegRule</code></pre><p>Simplex quadrature rule.</p><p>Used for integration on the standard triangle or the standard tetrahedron.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L391-L397">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.SimplexRule" href="#FinEtools.IntegRuleModule.SimplexRule"><code>FinEtools.IntegRuleModule.SimplexRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimplexRule(dim=1, npts=1)</code></pre><p>Return simplex rule, appropriate for the manifold dimension <code>dim</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L404-L408">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TetRule" href="#FinEtools.IntegRuleModule.TetRule"><code>FinEtools.IntegRuleModule.TetRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TetRule &lt;: AbstractIntegRule</code></pre><p>Tetrahedral quadrature rule, used for integration on the standard tetrahedron.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L322-L326">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TetRule" href="#FinEtools.IntegRuleModule.TetRule"><code>FinEtools.IntegRuleModule.TetRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TetRule(npts=1)</code></pre><p>Tetrahedral integration rule. npts=number of points (1– one-point rule, 4 – four-point rule, 5 – five point rule).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L333-L339">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TrapezoidalRule" href="#FinEtools.IntegRuleModule.TrapezoidalRule"><code>FinEtools.IntegRuleModule.TrapezoidalRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TrapezoidalRule &lt;: AbstractIntegRule</code></pre><p>The trapezoidal rule.</p><p>The rule is applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L428-L434">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TrapezoidalRule" href="#FinEtools.IntegRuleModule.TrapezoidalRule"><code>FinEtools.IntegRuleModule.TrapezoidalRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TrapezoidalRule(dim=1)</code></pre><p>Trapezoidal rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L442-L446">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TriRule" href="#FinEtools.IntegRuleModule.TriRule"><code>FinEtools.IntegRuleModule.TriRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TriRule &lt;: AbstractIntegRule</code></pre><p>Triangular quadrature rule for integration on the standard triangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L17-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TriRule" href="#FinEtools.IntegRuleModule.TriRule"><code>FinEtools.IntegRuleModule.TriRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TriRule(npts=1)</code></pre><p>Type for triangular quadrature rule.  Used for integration of the standard triangle, which is between 0 and 1 in both parametric coordinates. <code>npts</code> = number of points (1– one-point rule, 3 – three-point rule, 6 – six  point rule, 9 –nine point rule, 10 – Strang 10 point, order 13, degree of  precision 7, rule), 12 and 13–twelve- and thirteen-point rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegRuleModule.jl#L28-L36">source</a></section><h2><a class="nav-anchor" id="Integration-domain-1" href="#Integration-domain-1">Integration domain</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain" href="#FinEtools.IntegDomainModule.IntegDomain"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntegDomain{S&lt;:AbstractFESet, F&lt;:Function}</code></pre><p>Integration domain.</p><ul><li><code>T</code> = type of finite element set.  The type of the FE set will be dependent upon the operations required. For instance, for interior (volume) integrals such as body load or the stiffness hexahedral H8 may be used, whereas for boundary  (surface) integrals quadrilateral Q4 would be needed.</li><li><code>F</code> = type of function to return the &quot;other&quot; dimension.</li></ul><p>An integration domain consists of the finite elements that approximate the geometry, the function to supply the &quot;missing&quot; (other) dimension, indication whether or not the integration domain represents an axially symmetric situation, and integration rule used to evaluate integrals over the domain.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegDomainModule.jl#L18-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Bool,Float64}} where S&lt;:AbstractFESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Bool,Float64}} where S&lt;:AbstractFESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegDomain(fes::S, integration_rule::AbstractIntegRule, axisymmetric::Bool,
  otherdimension::FFlt) where {S&lt;:AbstractFESet}</code></pre><p>Construct for axially symmetric models. The other dimension is given as a number.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegDomainModule.jl#L80-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Bool}} where S&lt;:AbstractFESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Bool}} where S&lt;:AbstractFESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegDomain(fes::S, integration_rule::AbstractIntegRule,
  axisymmetric::Bool) where {S&lt;:AbstractFESet}</code></pre><p>Construct with the default orientation matrix (identity), for axially symmetric models. The other dimension is the default unity (1.0).</p><p>This will probably be called when <code>axisymmetric = true</code>, since the default is <code>axisymmetric = false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegDomainModule.jl#L66-L75">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Float64}} where S&lt;:AbstractFESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule,Float64}} where S&lt;:AbstractFESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegDomain(fes::S, integration_rule::AbstractIntegRule,
  otherdimension::FFlt) where {S&lt;:AbstractFESet}</code></pre><p>Construct with the default orientation matrix (identity), and constant other dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegDomainModule.jl#L51-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule}} where S&lt;:AbstractFESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,AbstractIntegRule}} where S&lt;:AbstractFESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegDomain(fes::S, integration_rule::AbstractIntegRule) where {S&lt;:AbstractFESet}</code></pre><p>Construct with the default orientation matrix (identity), and the other dimension  being the default 1.0.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/IntegDomainModule.jl#L41-L46">source</a></section><h2><a class="nav-anchor" id="Assembly-of-matrices-and-vectors-1" href="#Assembly-of-matrices-and-vectors-1">Assembly of matrices and vectors</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.AbstractSysmatAssembler" href="#FinEtools.AssemblyModule.AbstractSysmatAssembler"><code>FinEtools.AssemblyModule.AbstractSysmatAssembler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractSysmatAssembler</code></pre><p>Abstract type of system-matrix assembler.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.AbstractSysvecAssembler" href="#FinEtools.AssemblyModule.AbstractSysvecAssembler"><code>FinEtools.AssemblyModule.AbstractSysvecAssembler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractSysvecAssembler</code></pre><p>Abstract type of system vector assembler.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L293-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparse" href="#FinEtools.AssemblyModule.SysmatAssemblerSparse"><code>FinEtools.AssemblyModule.SysmatAssemblerSparse</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SysmatAssemblerSparse{T&lt;:Number} &lt;: AbstractSysmatAssembler</code></pre><p>Type for assembling a sparse global matrix from elementwise matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L19-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparse-Union{Tuple{}, Tuple{T}, Tuple{T}} where T&lt;:Number" href="#FinEtools.AssemblyModule.SysmatAssemblerSparse-Union{Tuple{}, Tuple{T}, Tuple{T}} where T&lt;:Number"><code>FinEtools.AssemblyModule.SysmatAssemblerSparse</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SysmatAssemblerSparse(zero::T=0.0) where {T&lt;:Number}</code></pre><p>Construct blank system matrix assembler. The matrix entries are of type <code>T</code>.</p><p><strong>Example</strong></p><p>This is how a sparse matrix is assembled from two rectangular dense matrices.</p><pre><code class="language-none">	a = SysmatAssemblerSparse(0.0)                                                        
	startassembly!(a, 5, 5, 3, 7, 7)    
	m = [0.24406   0.599773    0.833404  0.0420141                                             
		0.786024  0.00206713  0.995379  0.780298                                              
		0.845816  0.198459    0.355149  0.224996]                                     
	assemble!(a, m, [1 7 5], [5 2 1 4])        
	m = [0.146618  0.53471   0.614342    0.737833                                              
		 0.479719  0.41354   0.00760941  0.836455                                              
		 0.254868  0.476189  0.460794    0.00919633                                            
		 0.159064  0.261821  0.317078    0.77646                                               
		 0.643538  0.429817  0.59788     0.958909]                                   
	assemble!(a, m, [2 3 1 7 5], [6 7 3 4])                                        
	A = makematrix!(a) </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L33-L56">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SysmatAssemblerSparseHRZLumpingSymm{T&lt;:Number} &lt;: AbstractSysmatAssembler</code></pre><p>Assembler for a <strong>symmetric lumped square</strong> matrix  assembled from  <strong>symmetric square</strong> matrices. </p><p>Reference: A note on mass lumping and related processes in the finite element method, E. Hinton, T. Rock, O. C. Zienkiewicz, Earthquake Engineering &amp; Structural Dynamics, volume 4, number 3, 245–249, 1976. }</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L364-L375">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm-Union{Tuple{}, Tuple{T}, Tuple{T}} where T&lt;:Number" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm-Union{Tuple{}, Tuple{T}, Tuple{T}} where T&lt;:Number"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SysmatAssemblerSparseHRZLumpingSymm(zer::T=0.0) where {T&lt;:Number}</code></pre><p>Construct blank system matrix assembler. The matrix entries are of type <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L386-L390">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseSymm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SysmatAssemblerSparseSymm{T&lt;:Number} &lt;: AbstractSysmatAssembler</code></pre><p>Assembler for a <strong>symmetric square</strong> matrix  assembled from symmetric square matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L145-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseSymm-Union{Tuple{}, Tuple{T}, Tuple{T}} where T&lt;:Number" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm-Union{Tuple{}, Tuple{T}, Tuple{T}} where T&lt;:Number"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseSymm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SysmatAssemblerSparseSymm(zero::T=0.0) where {T&lt;:Number}</code></pre><p>Construct blank system matrix assembler for symmetric matrices. The matrix entries are of type <code>T</code>.</p><p><strong>Example</strong></p><p>This is how a symmetric sparse matrix is assembled from two square dense matrices.</p><pre><code class="language-none">	a = SysmatAssemblerSparseSymm(0.0)                                                        
	startassembly!(a, 5, 5, 3, 7, 7)    
	m = [0.24406   0.599773    0.833404  0.0420141                                             
		0.786024  0.00206713  0.995379  0.780298                                              
		0.845816  0.198459    0.355149  0.224996]                                     
	assemble!(a, m&#39;*m, [5 2 1 4], [5 2 1 4])        
	m = [0.146618  0.53471   0.614342    0.737833                                              
		 0.479719  0.41354   0.00760941  0.836455                                              
		 0.254868  0.476189  0.460794    0.00919633                                            
		 0.159064  0.261821  0.317078    0.77646                                               
		 0.643538  0.429817  0.59788     0.958909]                                   
	assemble!(a, m&#39;*m, [2 3 1 5], [2 3 1 5])                                        
	A = makematrix!(a) </code></pre><p><strong>See also</strong></p><p>[]</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L161-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssembler" href="#FinEtools.AssemblyModule.SysvecAssembler"><code>FinEtools.AssemblyModule.SysvecAssembler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SysvecAssembler</code></pre><p>Assembler for the system vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L300-L304">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssembler-Union{Tuple{}, Tuple{T}, Tuple{T}} where T&lt;:Number" href="#FinEtools.AssemblyModule.SysvecAssembler-Union{Tuple{}, Tuple{T}, Tuple{T}} where T&lt;:Number"><code>FinEtools.AssemblyModule.SysvecAssembler</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SysvecAssembler(zero::T=0.0) where {T&lt;:Number}</code></pre><p>Construct blank system vector assembler. The vector entries are of type <code>T</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/AssemblyModule.jl#L310-L314">source</a></section><h2><a class="nav-anchor" id="Mesh-import/export-1" href="#Mesh-import/export-1">Mesh import/export</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.AbaqusExporter" href="#FinEtools.MeshExportModule.AbaqusExporter"><code>FinEtools.MeshExportModule.AbaqusExporter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbaqusExporter</code></pre><p>Export mesh to Abaqus.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/MeshExportModule.jl#L312-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRANExporter" href="#FinEtools.MeshExportModule.NASTRANExporter"><code>FinEtools.MeshExportModule.NASTRANExporter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>NASTRANExporter</p><p>Export mesh to Abaqus.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/MeshExportModule.jl#L951-L955">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.STLExporter" href="#FinEtools.MeshExportModule.STLExporter"><code>FinEtools.MeshExportModule.STLExporter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>STLExporter</p><p>Export surface mesh as STL file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/MeshExportModule.jl#L1060-L1064">source</a></section><h2><a class="nav-anchor" id="Vector-cache-utilities-1" href="#Vector-cache-utilities-1">Vector-cache utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache" href="#FinEtools.VectorCacheModule.VectorCache"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">VectorCache{T&lt;:Number, F&lt;:Function}</code></pre><p>Type for caching vectors.</p><p><code>T</code> = type of the entries of the vector, <code>F</code> = type of the function to update the entries of the vector.</p><p>Signature of the function to fill the cache with the value of the vector at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and, if convenient, also the finite element label, <code>fe_label</code>. Finally, the value of the vector may also depend on the <code>time</code> (or the load factor):</p><pre><code class="language-none">fillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt; time::FFlt = 0.0)</code></pre><p>The cache <code>cacheout</code> is filled with the value  of the vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/VectorCacheModule.jl#L10-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">VectorCache(vector::FVec{T}) where {T&lt;:Number}</code></pre><p>Construct vector cache. The <em>constant</em> vector is given.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/VectorCacheModule.jl#L86-L90">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F,Float64}} where F&lt;:Function where T&lt;:Number" href="#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F,Float64}} where F&lt;:Function where T&lt;:Number"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">VectorCache(::Type{T}, nentries::FInt, fillcache!::F, time::FFlt) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct vector cache. The function to fill the vector cache is given.</p><p>This constructor is intended for <em>time-dependent</em> vector caches. This function needs to have a signature of</p><pre><code class="language-none">fillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt; time::FFlt = 0.0)
    Calculate the vector and copy it into the cache....
    return forceout
end</code></pre><p>and it needs to  fill in the cache <code>cacheout</code> with the current vector at the location <code>XYZ</code>, using the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>, if appropriate. The time can also be supplied (keyword argument <code>time</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/VectorCacheModule.jl#L63-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F&lt;:Function where T&lt;:Number" href="#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F&lt;:Function where T&lt;:Number"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">VectorCache(::Type{T}, nentries::FInt, fillcache!::F) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct vector cache. The function to fill the vector cache is given.</p><p>This constructor is intended for <em>time-independent</em> vector caches. This function needs to have a signature of</p><pre><code class="language-none">fillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    Calculate the vector and copy it into the cache....
    return forceout
end</code></pre><p>and it needs to  fill in the cache <code>cacheout</code> with the current vector at the location <code>XYZ</code>, using the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>, if appropriate.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/VectorCacheModule.jl#L37-L54">source</a></section><h2><a class="nav-anchor" id="Surface-normal-utilities-1" href="#Surface-normal-utilities-1">Surface-normal utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal" href="#FinEtools.SurfaceNormalModule.SurfaceNormal"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SurfaceNormal{F&lt;:Function}</code></pre><p>stop listening noise me of being sure moon moon moon9 Exterior surface normal type.</p><p>Normalized to unit length.</p><p>Signature of the function to compute the value of the unit normal at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="language-none">getnormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The buffer <code>normalout</code> is filled with the value  of the normal vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/SurfaceNormalModule.jl#L14-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Int64}" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Int64}"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SurfaceNormal(ndimensions::FInt)</code></pre><p>Construct surface normal evaluator when the default calculation of the normal vector based on the columns of the Jacobian matrix should be used. This function needs to have a signature of</p><pre><code class="language-none">function computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    Calculate the normal and copy it into the buffer....
    return normalout # return the buffer
end</code></pre><p>and it needs to  fill in the buffer <code>normalout</code> with the current vector at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>.</p><p>The normal vector has <code>ndimensions</code> entries.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/SurfaceNormalModule.jl#L58-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SurfaceNormal(vector::FVec{T}) where {T&lt;:Number}</code></pre><p>Construct surface normal vector when the <em>constant</em> normal vector is given.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/SurfaceNormalModule.jl#L94-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Int64,F}} where F&lt;:Function" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Int64,F}} where F&lt;:Function"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SurfaceNormal(ndimensions::FInt, computenormal!::F) where {F&lt;:Function}</code></pre><p>Construct surface normal evaluator when the function to compute the normal vector is given. This function needs to have a signature of</p><pre><code class="language-none">function computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    Calculate the normal and copy it into the buffer....
    return normalout # return the buffer
end</code></pre><p>and it needs to  fill in the buffer <code>normalout</code> with the current vector at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/SurfaceNormalModule.jl#L38-L52">source</a></section><h2><a class="nav-anchor" id="Force-intensity-1" href="#Force-intensity-1">Force intensity</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity" href="#FinEtools.ForceIntensityModule.ForceIntensity"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ForceIntensity{T&lt;:Number, F&lt;:Function}</code></pre><p>Distributed force (force intensity) type.</p><p>The force intensity class. The physical units are force per unit volume, where volume depends on to which manifold the force is applied:</p><ul><li>force/length^3 (when applied to a 3-D solid),</li><li>force/length^2 (when applied to a surface),</li><li>force/length^1 (when applied along a curve), or</li><li>force/length^0 (when applied at a point).</li></ul><p>Signature of the function to compute the value of the force  at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="language-none">getforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The buffer <code>forceout</code> is filled with the value  of the force. The vector <code>forceout</code> is also returned for convenience.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/ForceIntensityModule.jl#L11-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ForceIntensity(force::FVec{T}) where {T&lt;:Number}</code></pre><p>Construct force intensity when the constant <code>force</code> vector is given.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/ForceIntensityModule.jl#L113-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F,Float64}} where F&lt;:Function where T&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F,Float64}} where F&lt;:Function where T&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ForceIntensity(::Type{T}, ndofn::FInt, computeforce!::F, time::FFlt) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct force intensity when the function to compute the intensity vector is given.</p><p>This constructor is intended for time-dependent force intensity caches.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> = the type of the elements of the force vector, typically floating-point or complex floating-point numbers,</li><li><code>ndofn</code> = number of elements of the force vector (the length of the force vector),</li><li><code>computeforce!</code> = callback function,</li><li><code>time</code> = initial time.</li></ul><p>The function <code>computeforce!</code> needs to have a signature of</p><pre><code class="language-none">function computeforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt; time::FFlt = 0.0)
	Calculate the force  and copy it into the buffer....
	return forceout
end</code></pre><p>and it needs to  fill in the buffer <code>forceout</code> with the current force at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>. The initial <code>time</code> is given.</p><p>The time needs to be set with <code>settime!</code> before calling <code>updateforce!</code> as follows:</p><pre><code class="language-none">XYZ = reshape([0.0, 0.0], 2, 1)
tangents = reshape([0.0, 1.0], 2, 1)
fe_label = 0
setvector!(v, XYZ, tangents, fe_label; time::FFlt = 0.0) = begin
    return (time &lt; 5.0 ?  v .= [10.0] : v .= [0.0])
end
vector = [10.0]
fi = ForceIntensity(FFlt, length(vector), setvector!, 0.0)
v = updateforce!(fi, XYZ, tangents, fe_label)
@test v == [10.0]
settime!(fi, 6.0)
v = updateforce!(fi, XYZ, tangents, fe_label)
@test v == [0.0]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/ForceIntensityModule.jl#L65-L107">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F&lt;:Function where T&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F&lt;:Function where T&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ForceIntensity(::Type{T}, ndofn::FInt, computeforce!::F) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct force intensity when the function to compute the intensity vector is given.</p><p>This constructor is intended for <em>time-independent</em> vector caches.</p><p><strong>Arguments</strong></p><ul><li><code>T</code> = the type of the elements of the force vector, typically floating-point or complex floating-point numbers,</li><li><code>ndofn</code> = number of elements of the force vector (the length of the force vector),</li><li><code>computeforce!</code> = callback function.</li></ul><p>The function <code>computeforce!</code> needs to have a signature of</p><pre><code class="language-none">function computeforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    Calculate the force  and copy it into the buffer....
    return forceout
end</code></pre><p>and it needs to  fill in the buffer <code>forceout</code> with the current force at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/ForceIntensityModule.jl#L37-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{T}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{T}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ForceIntensity(force::T) where {T&lt;:Number}</code></pre><p>Construct force intensity when the force is given as a scalar value.</p><p>The dimension of the force vector in this case is 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/ForceIntensityModule.jl#L122-L128">source</a></section><h2><a class="nav-anchor" id="FEM-machines-1" href="#FEM-machines-1">FEM machines</a></h2><h3><a class="nav-anchor" id="Base-1" href="#Base-1">Base</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.AbstractFEMM" href="#FinEtools.FEMMBaseModule.AbstractFEMM"><code>FinEtools.FEMMBaseModule.AbstractFEMM</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractFEMM</code></pre><p>Abstract type for all finite element model machines.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FEMMBaseModule.jl#L27-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMBase" href="#FinEtools.FEMMBaseModule.FEMMBase"><code>FinEtools.FEMMBaseModule.FEMMBase</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FEMMBase{S&lt;:AbstractFESet, F&lt;:Function} &lt;: AbstractFEMM</code></pre><p>Class for base finite element modeling machine.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FEMMBaseModule.jl#L34-L38">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMBase-Union{Tuple{IntegDomain{S,F}}, Tuple{F}, Tuple{S}} where F&lt;:Function where S&lt;:AbstractFESet" href="#FinEtools.FEMMBaseModule.FEMMBase-Union{Tuple{IntegDomain{S,F}}, Tuple{F}, Tuple{S}} where F&lt;:Function where S&lt;:AbstractFESet"><code>FinEtools.FEMMBaseModule.FEMMBase</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">FEMMBase(integdomain::IntegDomain{S, F}) where {S&lt;:AbstractFESet, F&lt;:Function}</code></pre><p>Construct with the default orientation matrix (identity).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/FEMMBaseModule.jl#L44-L48">source</a></section><h3><a class="nav-anchor" id="Heat-diffusion-1" href="#Heat-diffusion-1">Heat diffusion</a></h3><pre><code class="language-">Modules = [FinEtools, FinEtools.FEMMHeatDiffModule, FinEtools.FEMMHeatDiffSurfModule]
Private = true
Order = [:type]</code></pre><h3><a class="nav-anchor" id="Acoustics-1" href="#Acoustics-1">Acoustics</a></h3><pre><code class="language-">Modules = [FinEtools, FinEtools.FEMMAcoustModule, FinEtools.FEMMAcoustSurfModule]
Private = true
Order = [:type]</code></pre><h3><a class="nav-anchor" id="Linear-deformation-1" href="#Linear-deformation-1">Linear deformation</a></h3><pre><code class="language-">Modules = [FinEtools, FinEtools.DeforModelRedModule, FinEtools.FEMMDeforLinearBaseModule, FinEtools.FEMMDeforLinearModule, FinEtools.FEMMDeforWinklerModule, FinEtools.FEMMDeforLinearMSModule, FinEtools.FEMMDeforSurfaceDampingModule, FinEtools.FEMMDeforLinearNICEModule, FinEtools.FEMMDeforLinearESNICEModule]
Private = true
Order = [:type]</code></pre><h2><a class="nav-anchor" id="Material-models-1" href="#Material-models-1">Material models</a></h2><h3><a class="nav-anchor" id="Material-model-abstractions-1" href="#Material-model-abstractions-1">Material model abstractions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatModule.AbstractMat" href="#FinEtools.MatModule.AbstractMat"><code>FinEtools.MatModule.AbstractMat</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractMat</code></pre><p>Abstract type of material.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d500e7347072bc127a83b041831cc62af40d79ee/src/MatModule.jl#L10-L14">source</a></section><h3><a class="nav-anchor" id="Material-models-for-acoustics-1" href="#Material-models-for-acoustics-1">Material models for acoustics</a></h3><pre><code class="language-">Modules = [FinEtools, FinEtools.MatModule, FinEtools.MatAcoustFluidModule]
Private = true
Order = [:type]</code></pre><h3><a class="nav-anchor" id="Material-models-for-heat-diffusion-1" href="#Material-models-for-heat-diffusion-1">Material models for heat diffusion</a></h3><pre><code class="language-">Modules = [FinEtools, FinEtools.MatModule, FinEtools.MatHeatDiffModule]
Private = true
Order = [:type]</code></pre><h3><a class="nav-anchor" id="Material-for-deformation,-base-functionality-1" href="#Material-for-deformation,-base-functionality-1">Material for deformation, base functionality</a></h3><pre><code class="language-">Modules = [FinEtools, FinEtools.MatDeforModule]
Private = true
Order = [:type]</code></pre><h3><a class="nav-anchor" id="Material-models-for-elasticity-1" href="#Material-models-for-elasticity-1">Material models for elasticity</a></h3><pre><code class="language-">Modules = [FinEtools, FinEtools.MatDeforLinearElasticModule, FinEtools.MatDeforElastIsoModule, FinEtools.MatDeforElastOrthoModule,]
Private = true
Order = [:type]</code></pre><footer><hr/><a class="previous" href="../guide/guide.html"><span class="direction">Previous</span><span class="title">Guide</span></a><a class="next" href="functions.html"><span class="direction">Next</span><span class="title">Functions</span></a></footer></article></body></html>
