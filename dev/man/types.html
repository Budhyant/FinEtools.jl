<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · FinEtools.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>FinEtools.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="../guide/guide.html">Guide</a></li><li><span class="toctext">Types and Functions</span><ul><li class="current"><a class="toctext" href="types.html">Types</a><ul class="internal"><li><a class="toctext" href="#Coordinate-systems-1">Coordinate systems</a></li><li><a class="toctext" href="#Finite-element-sets-1">Finite element sets</a></li><li><a class="toctext" href="#Finite-element-nodes-1">Finite element nodes</a></li><li><a class="toctext" href="#Finite-element-node-to-element-map-1">Finite element node-to-element map</a></li><li><a class="toctext" href="#Fields-1">Fields</a></li><li><a class="toctext" href="#Integration-1">Integration</a></li><li><a class="toctext" href="#Assembly-of-matrices-and-vectors-1">Assembly of matrices and vectors</a></li><li><a class="toctext" href="#Mesh-import/export-1">Mesh import/export</a></li><li><a class="toctext" href="#Vector-cache-utilities-1">Vector-cache utilities</a></li><li><a class="toctext" href="#Surface-normal-utilities-1">Surface-normal utilities</a></li><li><a class="toctext" href="#Force-intensity-1">Force intensity</a></li><li><a class="toctext" href="#FEM-machine:-Base-1">FEM machine: Base</a></li><li><a class="toctext" href="#FEM-machine:-Heat-diffusion-1">FEM machine: Heat diffusion</a></li><li><a class="toctext" href="#FEM-machine:-Acoustics-1">FEM machine: Acoustics</a></li><li><a class="toctext" href="#FEM-machine:-Linear-deformation-1">FEM machine: Linear deformation</a></li><li><a class="toctext" href="#Material-models-1">Material models</a></li></ul></li><li><a class="toctext" href="functions.html">Functions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Types and Functions</li><li><a href="types.html">Types</a></li></ul><a class="edit-page" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/master/docs/src/man/types.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Types</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h1><h2><a class="nav-anchor" id="Coordinate-systems-1" href="#Coordinate-systems-1">Coordinate systems</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys" href="#FinEtools.CSysModule.CSys"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Type for coordinate system transformations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/CSysModule.jl#L11-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{Array{Float64,2}}" href="#FinEtools.CSysModule.CSys-Tuple{Array{Float64,2}}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CSys(csmat::FFltMat)</code></pre><p>Construct coordinate system when the rotation matrix is given.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/CSysModule.jl#L42-L46">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{Int64,Int64}" href="#FinEtools.CSysModule.CSys-Tuple{Int64,Int64}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CSys(sdim::FInt, mdim::FInt)</code></pre><p>Construct coordinate system for isotropic-material used with isoparametric finite elements.</p><ul><li><code>sdim</code> = number of space dimensions,</li><li><code>mdim</code> = number of manifold dimensions of the finite element in which the coordinate system  is being evaluated.</li></ul><p><strong>Warning</strong></p><p>If  the coordinate system matrix  should be identity, better use the constructor for this specific situation, <code>CSys(dim::FInt)</code>. That will be much more efficient.</p><p><strong>See also</strong></p><p><code>gen_iso_csmat</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/CSysModule.jl#L65-L80">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Tuple{Int64}" href="#FinEtools.CSysModule.CSys-Tuple{Int64}"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CSys(dim::FInt)</code></pre><p>Construct coordinate system when the rotation matrix is the identity.</p><p><code>dim</code> = is the space dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/CSysModule.jl#L54-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{Int64,Int64,F}} where F&lt;:Function" href="#FinEtools.CSysModule.CSys-Union{Tuple{F}, Tuple{Int64,Int64,F}} where F&lt;:Function"><code>FinEtools.CSysModule.CSys</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CSys(sdim::FInt, mdim::FInt, computecsmat::F) where {F&lt;:Function}</code></pre><p>Construct ccoordinate system when the function to compute the rotation matrix is given.</p><p>The function signature: <code>update!(csmatout::FFltMat, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code> where</p><ul><li><code>csmatout</code>= output matrix buffer, </li><li><code>XYZ</code>= location  in physical coordinates,</li><li><code>tangents</code>= tangent vector matrix, tangents to the parametric coordinate curves  in the element,</li><li><code>fe_label</code>= finite element label.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/CSysModule.jl#L22-L36">source</a></section><h2><a class="nav-anchor" id="Finite-element-sets-1" href="#Finite-element-sets-1">Finite element sets</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetH20" href="#FinEtools.FESetModule.FESetH20"><code>FinEtools.FESetModule.FESetH20</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetH20</code></pre><p>Type for sets of volume-like of hexahedral finite elements with 20 nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L837-L841">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetH27" href="#FinEtools.FESetModule.FESetH27"><code>FinEtools.FESetModule.FESetH27</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetH27</code></pre><p>Type for sets of volume-like of hexahedral finite elements with 27 nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L982-L986">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetH8" href="#FinEtools.FESetModule.FESetH8"><code>FinEtools.FESetModule.FESetH8</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetH8</code></pre><p>Type for sets of volume-like of hexahedral finite elements with eight nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L770-L774">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetL2" href="#FinEtools.FESetModule.FESetL2"><code>FinEtools.FESetModule.FESetL2</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetL2</code></pre><p>Type for sets of curve-like of finite elements with two nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L431-L435">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetL3" href="#FinEtools.FESetModule.FESetL3"><code>FinEtools.FESetModule.FESetL3</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetL3</code></pre><p>Type for sets of curve-like of finite elements with three nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L462-L466">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetP1" href="#FinEtools.FESetModule.FESetP1"><code>FinEtools.FESetModule.FESetP1</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetP1</code></pre><p>Type for sets of point-like of finite elements.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L400-L404">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ4" href="#FinEtools.FESetModule.FESetQ4"><code>FinEtools.FESetModule.FESetQ4</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetQ4</code></pre><p>Type for sets of surface-like of quadrilateral finite elements with four nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L542-L546">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ8" href="#FinEtools.FESetModule.FESetQ8"><code>FinEtools.FESetModule.FESetQ8</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetQ8</code></pre><p>Type for sets of surface-like of quadrilateral finite elements with eight nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L643-L647">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetQ9" href="#FinEtools.FESetModule.FESetQ9"><code>FinEtools.FESetModule.FESetQ9</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetQ9</code></pre><p>Type for sets of surface-like of quadrilateral finite elements with nine nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L589-L593">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT10" href="#FinEtools.FESetModule.FESetT10"><code>FinEtools.FESetModule.FESetT10</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetT10</code></pre><p>Type for sets of volume-like of tetrahedral finite elements with 10 nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L1151-L1155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT3" href="#FinEtools.FESetModule.FESetT3"><code>FinEtools.FESetModule.FESetT3</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetT3</code></pre><p>Type for sets of surface-like of triangular finite elements with three nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L502-L506">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT4" href="#FinEtools.FESetModule.FESetT4"><code>FinEtools.FESetModule.FESetT4</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetT4</code></pre><p>Type for sets of volume-like of tetrahedral finite elements with four nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L1104-L1108">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FESetModule.FESetT6" href="#FinEtools.FESetModule.FESetT6"><code>FinEtools.FESetModule.FESetT6</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FESetT6</code></pre><p>Type for sets of surface-like of triangular finite elements with six nodes.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FESetModule.jl#L712-L716">source</a></section><h2><a class="nav-anchor" id="Finite-element-nodes-1" href="#Finite-element-nodes-1">Finite element nodes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeSetModule.FENodeSet" href="#FinEtools.FENodeSetModule.FENodeSet"><code>FinEtools.FENodeSetModule.FENodeSet</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Finite element node set type.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FENodeSetModule.jl#L11-L13">source</a></section><h2><a class="nav-anchor" id="Finite-element-node-to-element-map-1" href="#Finite-element-node-to-element-map-1">Finite element node-to-element map</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Map from finite element nodes to the finite elements connecting them.</p><p>For each  node referenced in the connectivity of the finite element set on input, the numbers of the individual finite elements that reference that node is stored in an array in the array <code>map</code>.         Example: </p><pre><code class="language-none">fes.conn= [7,6,5;
            4,1,3;
            3,7,5];
The map reads
    map[1] = [2];
    map[2] = [];#  note that node number 2 is not referenced by the connectivity
    map[3] = [2,3];
    map[4] = [2];
    map[5] = [1,3];
    map[6] = [1];
    map[7] = [1,3];</code></pre><p>The individual elements from the connectivity that reference node number 5 are 1 and 3, so that <code>fes.conn(map[5],:)</code>includes all the nodes that are connected to node 5 (including node 5 itself).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FENodeToFEMapModule.jl#L10-L35">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT,N}},1},Int64}} where IT&lt;:Integer where N" href="#FinEtools.FENodeToFEMapModule.FENodeToFEMap-Union{Tuple{IT}, Tuple{N}, Tuple{Array{Tuple{Vararg{IT,N}},1},Int64}} where IT&lt;:Integer where N"><code>FinEtools.FENodeToFEMapModule.FENodeToFEMap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">FENodeToFEMap(conns::FIntMat,nmax::FInt)</code></pre><p>Map from finite element nodes to the finite elements connecting them.</p><p><code>nmax</code> = largest possible node number</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FENodeToFEMapModule.jl#L44-L50">source</a></section><h2><a class="nav-anchor" id="Fields-1" href="#Fields-1">Fields</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FieldModule.Field" href="#FinEtools.FieldModule.Field"><code>FinEtools.FieldModule.Field</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Field</code></pre><p>Abstract field.</p><p>Expected  attributes:</p><ul><li><code>values::FMat{T}</code>: Array of degree of freedom parameters,  indexed by entity number</li><li><code>dofnums::FIntMat</code>: Array of degree of freedom numbers, indexed by entity number</li><li><code>is_fixed::Matrix{Bool}</code>: Array of Boolean flags, indexed by entity number</li><li><code>fixed_values::FMat{T}</code>: Array of fixed values, indexed by entity number</li><li><code>nfreedofs::FInt</code>: Total number of free degrees of freedom</li></ul><p>See also: <a href="man/@ref"><code>add_Field_fields()</code></a> .</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FieldModule.jl#L11-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField" href="#FinEtools.GeneralFieldModule.GeneralField"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GeneralField{T&lt;:Number} &lt;: Field</code></pre><p>General field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/GeneralFieldModule.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.GeneralFieldModule.GeneralField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.GeneralFieldModule.GeneralField</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">GeneralField(data::FMat{T}=[]) where {T&lt;:Number}</code></pre><p>Constructor of general field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/GeneralFieldModule.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField" href="#FinEtools.NodalFieldModule.NodalField"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NodalField{T&lt;:Number}</code></pre><p>Nodal field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/NodalFieldModule.jl#L12-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.NodalFieldModule.NodalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.NodalFieldModule.NodalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.NodalFieldModule.NodalField</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">NodalField(data::FMat{T}=[]) where {T&lt;:Number}</code></pre><p>Constructor of nodal field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/NodalFieldModule.jl#L21-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField" href="#FinEtools.ElementalFieldModule.ElementalField"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ElementalField{T&lt;:Number}</code></pre><p>Elemental field.</p><p>The values in the field are indexed by the element number.  This means  that there needs to be one field per finite element set.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/ElementalFieldModule.jl#L13-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ElementalFieldModule.ElementalField-Union{Tuple{}, Tuple{Array{T,2}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ElementalFieldModule.ElementalField</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>ElementalField(data::FMat{T}=[]) where {T&lt;:Number}</p><p>Constructor of elemental field.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/ElementalFieldModule.jl#L25-L29">source</a></section><h2><a class="nav-anchor" id="Integration-1" href="#Integration-1">Integration</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.GaussRule" href="#FinEtools.IntegRuleModule.GaussRule"><code>FinEtools.IntegRuleModule.GaussRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GaussRule</code></pre><p>The Gauss rule.</p><p>The rule is applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L153-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.GaussRule" href="#FinEtools.IntegRuleModule.GaussRule"><code>FinEtools.IntegRuleModule.GaussRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GaussRule(dim=1, order=1)</code></pre><p>Gauss rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L168-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalSimplexRule" href="#FinEtools.IntegRuleModule.NodalSimplexRule"><code>FinEtools.IntegRuleModule.NodalSimplexRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NodalSimplexRule</code></pre><p>The nodal-quadrature simplex rule.</p><p>The rule is applicable for line segments, triangles, tetrahedra.</p><p>The quadrature points must be given at the nodes in the order  in which the nodes are used in the definition of the element.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L488-L497">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.NodalSimplexRule" href="#FinEtools.IntegRuleModule.NodalSimplexRule"><code>FinEtools.IntegRuleModule.NodalSimplexRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NodalSimplexRule(dim=1)</code></pre><p>Nodal-quadrature simplex rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L505-L509">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.PointRule" href="#FinEtools.IntegRuleModule.PointRule"><code>FinEtools.IntegRuleModule.PointRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PointRule</code></pre><p>Class of point quadrature rule.</p><p>Used for integration on the standard &quot;point&quot; shape.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L370-L376">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.PointRule-Tuple{}" href="#FinEtools.IntegRuleModule.PointRule-Tuple{}"><code>FinEtools.IntegRuleModule.PointRule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">PointRule()</code></pre><p>POINT integration rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L383-L387">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.SimplexRule" href="#FinEtools.IntegRuleModule.SimplexRule"><code>FinEtools.IntegRuleModule.SimplexRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SimplexRule</code></pre><p>Simplex quadrature rule.</p><p>Used for integration on the standard triangle or the standard tetrahedron.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L392-L398">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TetRule" href="#FinEtools.IntegRuleModule.TetRule"><code>FinEtools.IntegRuleModule.TetRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TetRule</code></pre><p>Tetrahedral quadrature rule.</p><p>Used for integration on the standard tetrahedron.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L319-L325">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TetRule" href="#FinEtools.IntegRuleModule.TetRule"><code>FinEtools.IntegRuleModule.TetRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TetRule(npts=1)</code></pre><p>Tetrahedral integration rule. npts=number of points (1– one-point rule, 4 – four-point rule, 5 – five point rule).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L332-L338">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TrapezoidalRule" href="#FinEtools.IntegRuleModule.TrapezoidalRule"><code>FinEtools.IntegRuleModule.TrapezoidalRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TrapezoidalRule</code></pre><p>The trapezoidal rule.</p><p>The rule is applicable for a tensor product of  intervals -1 &lt;=x&lt;= +1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L424-L430">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TrapezoidalRule" href="#FinEtools.IntegRuleModule.TrapezoidalRule"><code>FinEtools.IntegRuleModule.TrapezoidalRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TrapezoidalRule(dim=1)</code></pre><p>Trapezoidal rule.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L438-L442">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TriRule" href="#FinEtools.IntegRuleModule.TriRule"><code>FinEtools.IntegRuleModule.TriRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TriRule</p><p>Triangular quadrature rule.</p><p>Used for integration on the standard triangle.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L11-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegRuleModule.TriRule" href="#FinEtools.IntegRuleModule.TriRule"><code>FinEtools.IntegRuleModule.TriRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TriRule(npts=1)</code></pre><p>Type for triangular quadrature rule.  Used for integration of the standard triangle, which is between 0 and 1 in both parametric coordinates. <code>npts</code> = number of points (1– one-point rule, 3 – three-point rule,  6 – six point rule, 10 – Strang 10 point, order 13, degree of precision 7, rule).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegRuleModule.jl#L24-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain" href="#FinEtools.IntegDomainModule.IntegDomain"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IntegDomain{S&lt;:FESet, F&lt;:Function}</code></pre><p>Integration domain.</p><ul><li><code>T</code> = type of finite element set.  The type of the FE set will be dependent upon the operations required. For instance, for interior (volume) integrals such as body load or the stiffness hexahedral H8 may be used, whereas for boundary  (surface) integrals quadrilateral Q4 would be needed.</li><li><code>F</code> = type of function to return the &quot;other&quot; dimension.</li></ul><p>An integration domain consists of the finite elements that approximate the geometry, the function to supply the &quot;missing&quot; (other) dimension, indication whether or not the integration domain represents an axially symmetric situation, and integration rule used to evaluate integrals over the domain.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegDomainModule.jl#L18-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,IntegRule,Bool,Float64}} where S&lt;:FESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,IntegRule,Bool,Float64}} where S&lt;:FESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegDomain(fes::S, integration_rule::IntegRule, axisymmetric::Bool,
  otherdimension::FFlt) where {S&lt;:FESet}</code></pre><p>Construct for axially symmetric models. The other dimension is given as a number.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegDomainModule.jl#L77-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,IntegRule,Bool}} where S&lt;:FESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,IntegRule,Bool}} where S&lt;:FESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegDomain(fes::S, integration_rule::IntegRule,
  axisymmetric::Bool) where {S&lt;:FESet}</code></pre><p>Construct with the default orientation matrix (identity), for axially symmetric models. The other dimension is  the default  unity (1.0).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegDomainModule.jl#L66-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,IntegRule,Float64}} where S&lt;:FESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,IntegRule,Float64}} where S&lt;:FESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegDomain(fes::S, integration_rule::IntegRule,
  otherdimension::FFlt) where {S&lt;:FESet}</code></pre><p>Construct with the default orientation matrix (identity), and constant other dimension.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegDomainModule.jl#L51-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,IntegRule}} where S&lt;:FESet" href="#FinEtools.IntegDomainModule.IntegDomain-Union{Tuple{S}, Tuple{S,IntegRule}} where S&lt;:FESet"><code>FinEtools.IntegDomainModule.IntegDomain</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">IntegDomain(fes::S, integration_rule::IntegRule) where {S&lt;:FESet}</code></pre><p>Construct with the default orientation matrix (identity), and the other dimension  being the default 1.0.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/IntegDomainModule.jl#L41-L46">source</a></section><h2><a class="nav-anchor" id="Assembly-of-matrices-and-vectors-1" href="#Assembly-of-matrices-and-vectors-1">Assembly of matrices and vectors</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseHRZLumpingSymm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SysmatAssemblerSparseHRZLumpingSymm{T&lt;:Number} &lt;: SysmatAssemblerBase</code></pre><p>Assembler for a SYMMETRIC LUMPED square matrix  assembled from  SYMMETRIC squared matrices. </p><p>Reference: A note on mass lumping and related processes in the finite element method, E. Hinton, T. Rock, O. C. Zienkiewicz, Earthquake Engineering &amp; Structural Dynamics, volume 4, number 3, 245–249, 1976. }</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/AssemblyModule.jl#L291-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysmatAssemblerSparseSymm" href="#FinEtools.AssemblyModule.SysmatAssemblerSparseSymm"><code>FinEtools.AssemblyModule.SysmatAssemblerSparseSymm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SysmatAssemblerSparseSymm{T&lt;:Number} &lt;: SysmatAssemblerBase</code></pre><p>Assembler for a SYMMETRIC square matrix  assembled from  SYMMETRIC squared matrices.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/AssemblyModule.jl#L113-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.AssemblyModule.SysvecAssembler" href="#FinEtools.AssemblyModule.SysvecAssembler"><code>FinEtools.AssemblyModule.SysvecAssembler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SysvecAssembler</code></pre><p>Assembler for the system vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/AssemblyModule.jl#L233-L237">source</a></section><h2><a class="nav-anchor" id="Mesh-import/export-1" href="#Mesh-import/export-1">Mesh import/export</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.AbaqusExporter" href="#FinEtools.MeshExportModule.AbaqusExporter"><code>FinEtools.MeshExportModule.AbaqusExporter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbaqusExporter</code></pre><p>Export mesh to Abaqus.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/MeshExportModule.jl#L312-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.NASTRANExporter" href="#FinEtools.MeshExportModule.NASTRANExporter"><code>FinEtools.MeshExportModule.NASTRANExporter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>NASTRANExporter</p><p>Export mesh to Abaqus.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/MeshExportModule.jl#L908-L912">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MeshExportModule.STLExporter" href="#FinEtools.MeshExportModule.STLExporter"><code>FinEtools.MeshExportModule.STLExporter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>STLExporter</p><p>Export surface mesh as STL file.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/MeshExportModule.jl#L1017-L1021">source</a></section><h2><a class="nav-anchor" id="Vector-cache-utilities-1" href="#Vector-cache-utilities-1">Vector-cache utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache" href="#FinEtools.VectorCacheModule.VectorCache"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">VectorCache{T&lt;:Number, F&lt;:Function}</code></pre><p>Type for caching vectors.</p><p><code>T</code> = type of the entries of the vector, <code>F</code> = type of the function to update the entries of the vector.</p><p>Signature of the function to fill the cache with the value of the vector at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="language-none">fillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The cache <code>cacheout</code> is filled with the value  of the vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/VectorCacheModule.jl#L10-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">VectorCache(vector::FVec{T}) where {T&lt;:Number}</code></pre><p>Construct vector cache. The constant vector is given.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/VectorCacheModule.jl#L51-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F&lt;:Function where T&lt;:Number" href="#FinEtools.VectorCacheModule.VectorCache-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F&lt;:Function where T&lt;:Number"><code>FinEtools.VectorCacheModule.VectorCache</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">VectorCache(::Type{T}, nentries::FInt, fillcache!::F) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct vector cache. The function to fill the vector cache is given. This function needs to have a signature of</p><pre><code class="language-none">fillcache!(cacheout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
Calculate the vector and copy it into the cache....
return forceout
end</code></pre><p>and it needs to  fill in the cache <code>cacheout</code> with the current vector at the location <code>XYZ</code>, using the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>, if appropriate.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/VectorCacheModule.jl#L31-L45">source</a></section><h2><a class="nav-anchor" id="Surface-normal-utilities-1" href="#Surface-normal-utilities-1">Surface-normal utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal" href="#FinEtools.SurfaceNormalModule.SurfaceNormal"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">SurfaceNormal{F&lt;:Function}</code></pre><p>Exterior surface normal type.</p><p>Normalized to unit length. </p><p>Signature of the function to compute the value of the unit normal  at any given point <code>XYZ</code>, using the columns of the Jacobian matrix  of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="language-none">getnormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The buffer <code>normalout</code> is filled with the value  of the normal vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/SurfaceNormalModule.jl#L14-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Int64}" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Tuple{Int64}"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SurfaceNormal(ndimensions::FInt)</code></pre><p>Construct surface normal evaluator when the default calculation of the normal vector based  on the columns of the Jacobian matrix should be used. This function needs to have a signature of</p><pre><code class="language-none">function computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt) 
    Calculate the normal and copy it into the buffer....
    return normalout # return the buffer
end</code></pre><p>and it needs to  fill in the buffer <code>normalout</code> with the current vector at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>.</p><p>The normal vector has <code>ndimensions</code> entries.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/SurfaceNormalModule.jl#L55-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SurfaceNormal(vector::FVec{T}) where {T&lt;:Number}</code></pre><p>Construct surface normal vector when the <em>constant</em> normal vector is given.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/SurfaceNormalModule.jl#L91-L95">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Int64,F}} where F&lt;:Function" href="#FinEtools.SurfaceNormalModule.SurfaceNormal-Union{Tuple{F}, Tuple{Int64,F}} where F&lt;:Function"><code>FinEtools.SurfaceNormalModule.SurfaceNormal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SurfaceNormal(ndimensions::FInt, computenormal!::F) where {F&lt;:Function}</code></pre><p>Construct surface normal evaluator when the function to compute the normal vector is given. This function needs to have a signature of</p><pre><code class="language-none">function computenormal!(normalout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
    Calculate the normal and copy it into the buffer....
    return normalout # return the buffer
end</code></pre><p>and it needs to  fill in the buffer <code>normalout</code> with the current vector at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/SurfaceNormalModule.jl#L35-L49">source</a></section><h2><a class="nav-anchor" id="Force-intensity-1" href="#Force-intensity-1">Force intensity</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity" href="#FinEtools.ForceIntensityModule.ForceIntensity"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ForceIntensity{T&lt;:Number, F&lt;:Function}</code></pre><p>Distributed force (force intensity) type. The force intensity class. The physical units are force per unit volume, where volume depends on to which manifold the force is applied:</p><ul><li>force/length^3 (when applied to a 3-D solid),</li><li>force/length^2 (when applied to a surface),</li><li>force/length^1 (when applied along a curve), or </li><li>force/length^0 (when applied at a point).</li></ul><p>Signature of the function to compute the value of the force  at any given point <code>XYZ</code>, using the columns of the Jacobian matrix of the element, <code>tangents</code>, and if necessary  also the finite element label, <code>fe_label</code>:</p><pre><code class="language-none">getforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)</code></pre><p>The buffer <code>forceout</code> is filled with the value  of the force.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/ForceIntensityModule.jl#L11-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{Array{T,1}}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ForceIntensity(force::FVec{T}) where {T&lt;:Number}</code></pre><p>Construct force intensity when the constant force vector is given.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/ForceIntensityModule.jl#L58-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F&lt;:Function where T&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{F}, Tuple{T}, Tuple{Type{T},Int64,F}} where F&lt;:Function where T&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ForceIntensity(::Type{T}, ndofn::FInt,
  computeforce!::F) where {T&lt;:Number, F&lt;:Function}</code></pre><p>Construct force intensity when the function to compute the intensity vector is given. This function needs to have a signature of</p><pre><code class="language-none">function computeforce!(forceout::FFltVec, XYZ::FFltMat, tangents::FFltMat, fe_label::FInt)
Calculate the force  and copy it into the buffer....
return forceout
end</code></pre><p>and it needs to  fill in the buffer <code>forceout</code> with the current force at the location <code>XYZ</code>, using if appropriate the information supplied in the Jacobian matrix <code>tangents</code>, and the label of the finite element, <code>fe_label</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/ForceIntensityModule.jl#L37-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{T}, Tuple{T}} where T&lt;:Number" href="#FinEtools.ForceIntensityModule.ForceIntensity-Union{Tuple{T}, Tuple{T}} where T&lt;:Number"><code>FinEtools.ForceIntensityModule.ForceIntensity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ForceIntensity(force::T) where {T&lt;:Number}</code></pre><p>Construct force intensity when the force is given as a scalar value. The dimension of the force vector in this case is 1.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/ForceIntensityModule.jl#L71-L76">source</a></section><h2><a class="nav-anchor" id="FEM-machine:-Base-1" href="#FEM-machine:-Base-1">FEM machine: Base</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMAbstractBase" href="#FinEtools.FEMMBaseModule.FEMMAbstractBase"><code>FinEtools.FEMMBaseModule.FEMMAbstractBase</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FEMMAbstractBase</code></pre><p>Abstract base type for all finite element models.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FEMMBaseModule.jl#L28-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMBase" href="#FinEtools.FEMMBaseModule.FEMMBase"><code>FinEtools.FEMMBaseModule.FEMMBase</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FEMMBase</code></pre><p>Class for base finite element modeling machine.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FEMMBaseModule.jl#L35-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMBaseModule.FEMMBase-Union{Tuple{IntegDomain{S,F}}, Tuple{F}, Tuple{S}} where F&lt;:Function where S&lt;:FESet" href="#FinEtools.FEMMBaseModule.FEMMBase-Union{Tuple{IntegDomain{S,F}}, Tuple{F}, Tuple{S}} where F&lt;:Function where S&lt;:FESet"><code>FinEtools.FEMMBaseModule.FEMMBase</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">FEMMBase(integdomain::IntegDomain{S, F}) where {S&lt;:FESet, F&lt;:Function}</code></pre><p>Construct with the default orientation matrix (identity).  </p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FEMMBaseModule.jl#L45-L49">source</a></section><h2><a class="nav-anchor" id="FEM-machine:-Heat-diffusion-1" href="#FEM-machine:-Heat-diffusion-1">FEM machine: Heat diffusion</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMHeatDiffModule.FEMMHeatDiff-Union{Tuple{M}, Tuple{F}, Tuple{S}, Tuple{IntegDomain{S,F},M}} where M&lt;:MatHeatDiff where F&lt;:Function where S&lt;:FESet" href="#FinEtools.FEMMHeatDiffModule.FEMMHeatDiff-Union{Tuple{M}, Tuple{F}, Tuple{S}, Tuple{IntegDomain{S,F},M}} where M&lt;:MatHeatDiff where F&lt;:Function where S&lt;:FESet"><code>FinEtools.FEMMHeatDiffModule.FEMMHeatDiff</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">FEMMHeatDiff(integdomain::IntegDomain{S, F}, material::M) where {S&lt;:FESet, F&lt;:Function, M&lt;:MatHeatDiff}</code></pre><p>Construct with the default orientation matrix (identity).  </p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FEMMHeatDiffModule.jl#L34-L38">source</a></section><h2><a class="nav-anchor" id="FEM-machine:-Acoustics-1" href="#FEM-machine:-Acoustics-1">FEM machine: Acoustics</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustModule.FEMMAcoust" href="#FinEtools.FEMMAcoustModule.FEMMAcoust"><code>FinEtools.FEMMAcoustModule.FEMMAcoust</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FEMMAcoust{S&lt;:FESet}</code></pre><p>Type for linear acoustics finite element modeling machine.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FEMMAcoustModule.jl#L23-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf" href="#FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf"><code>FinEtools.FEMMAcoustSurfModule.FEMMAcoustSurf</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FEMMAcoustSurf{S&lt;:FESet, F&lt;:Function, M} &lt;: FEMMAbstractBase</code></pre><p>Class for linear acoustics finite element modeling machine.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FEMMAcoustSurfModule.jl#L24-L28">source</a></section><h2><a class="nav-anchor" id="FEM-machine:-Linear-deformation-1" href="#FEM-machine:-Linear-deformation-1">FEM machine: Linear deformation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforLinearModule.FEMMDeforLinear" href="#FinEtools.FEMMDeforLinearModule.FEMMDeforLinear"><code>FinEtools.FEMMDeforLinearModule.FEMMDeforLinear</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FEMMDeforLinear{S&lt;:FESet, F&lt;:Function, P&lt;:PropertyDeformationLinear}</code></pre><p>Class for linear deformation finite element modeling machine.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FEMMDeforLinearModule.jl#L18-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforWinklerModule.FEMMDeforWinkler" href="#FinEtools.FEMMDeforWinklerModule.FEMMDeforWinkler"><code>FinEtools.FEMMDeforWinklerModule.FEMMDeforWinkler</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FEMMDeforWinkler{S&lt;:FESet, F&lt;:Function}</code></pre><p>Type for normal spring support  (Winkler).</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FEMMDeforWinklerModule.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping" href="#FinEtools.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping"><code>FinEtools.FEMMDeforSurfaceDampingModule.FEMMDeforSurfaceDamping</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">FEMMDeforSurfaceDamping{S&lt;:FESet, F&lt;:Function}</code></pre><p>Type for surface damping model.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/FEMMDeforSurfaceDampingModule.jl#L22-L26">source</a></section><h2><a class="nav-anchor" id="Material-models-1" href="#Material-models-1">Material models</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforModule.MatDefor" href="#FinEtools.MatDeforModule.MatDefor"><code>FinEtools.MatDeforModule.MatDefor</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MatDefor</code></pre><p>Abstract type that represents deformable materials.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/MatDeforModule.jl#L11-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforElastIsoModule.MatDeforElastIso" href="#FinEtools.MatDeforElastIsoModule.MatDeforElastIso"><code>FinEtools.MatDeforElastIsoModule.MatDeforElastIso</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MatDeforElastIso</code></pre><p>Linear isotropic elasticity  material.</p><pre><code class="language-none">tangentmoduli!::MTAN
update!::MUPD
thermalstrain!::MTHS</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/MatDeforElastIsoModule.jl#L14-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="FinEtools.MatDeforElastOrthoModule.MatDeforElastOrtho" href="#FinEtools.MatDeforElastOrthoModule.MatDeforElastOrtho"><code>FinEtools.MatDeforElastOrthoModule.MatDeforElastOrtho</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MatDeforElastOrtho</code></pre><p>Linear orthotropic elasticity  material.</p><pre><code class="language-tangentmoduli">  ms::MatDeforElastOrthoMS, D::FFltMat,
  t::FFlt, dt::FFlt, loc::FFltMat, label::FInt)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/PetrKryslUCSD/FinEtools.jl/blob/d06d01ad3a0973f5a853ce70b8c7d210a5f787fe/src/MatDeforElastOrthoModule.jl#L16-L28">source</a></section><footer><hr/><a class="previous" href="../guide/guide.html"><span class="direction">Previous</span><span class="title">Guide</span></a><a class="next" href="functions.html"><span class="direction">Next</span><span class="title">Functions</span></a></footer></article></body></html>
